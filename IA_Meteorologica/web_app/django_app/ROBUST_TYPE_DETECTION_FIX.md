# Robust Type Detection Fix for Multi-Output Columns

## Issue
When applying output conversions to columns generated by custom functions (like date normalization), the system was incorrectly detecting numeric columns as text type. This happened because it was using the original column type instead of the actual generated column types.

## Solution
Implemented the same robust type detection mechanism used by the "Column Details" button (showColumnDetails function).

## Changes Made

### 1. Updated `fetchColumnTypesForOutput` Function
**File**: `templates/normalize.html`

Now uses the exact same approach as `showColumnDetails`:
```javascript
// Use the exact same approach as showColumnDetails
const currentConfig = {};
if (normalizationConfig[column] && normalizationConfig[column][lastLayerIndex]) {
    currentConfig[column] = [normalizationConfig[column][lastLayerIndex]];
}

// Fetch with same parameters
const response = await fetch(`/api/datasets/${datasetId}/normalization/preview/`, {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify({
        normalization: currentConfig,
        sample_size: 10  // Same as showColumnDetails
    })
});
```

Uses `column_types_info` from the preview response:
```javascript
if (data.preview && data.preview[column] && data.preview[column].column_types_info) {
    const columnTypesInfo = data.preview[column].column_types_info;
    // Store both simplified types and detailed info
    outputIndicator.dataset.columnTypes = JSON.stringify(types);
    outputIndicator.dataset.columnTypesInfo = JSON.stringify(columnTypesInfo);
}
```

### 2. Enhanced `getOutputColumnType` Function
Now checks for detailed type information first:
```javascript
// First check if we have detailed column types info (from showColumnDetails approach)
if (outputIndicator && outputIndicator.dataset.columnTypesInfo) {
    const columnTypesInfo = JSON.parse(outputIndicator.dataset.columnTypesInfo);
    const colInfo = columnTypesInfo.find(col => col.name === outputColumnName);
    if (colInfo) {
        // Map specific types to 'numeric' or 'text'
        if (colInfo.type === 'integer' || colInfo.type === 'float' || colInfo.type === 'numeric') {
            return 'numeric';
        } else {
            return 'text';
        }
    }
}
```

### 3. Proactive Type Fetching
- When multi-output is detected, types are always fetched to ensure accuracy
- When adding a new output conversion, types are fetched if columns are available

### 4. Type Mapping
The system now correctly maps detailed types to the conversion system's expected types:
- `integer`, `float`, `numeric` → `'numeric'`
- Everything else → `'text'`

## How It Works

1. **Detection**: When a custom function creates multiple columns, the system detects it needs multi-output conversions.

2. **Type Fetching**: Uses the same preview API call as the "Column Details" button to get accurate type information.

3. **Storage**: Stores both simplified types (`numeric`/`text`) and detailed type info (`integer`, `float64`, etc.).

4. **Usage**: When determining which truncation dialog to show, it uses the accurate type information.

## Result
Now when you:
1. Apply a custom function that creates numeric columns from a text column
2. Add an output conversion
3. Select a generated numeric column (like `h_sin`, `trend`)
4. Choose TRUNCATE

The system correctly shows the decimal truncation dialog instead of the character limit dialog.

## Testing
The console will show messages like:
```
Fetching column types for accuracy...
Column types info from preview: [{"name":"trend","type":"float","dtype":"float64"}, ...]
Column trend: type=float, dtype=float64 → numeric
Found detailed type for trend: float (float64) → numeric
Truncate dialog for trend: detected type = numeric
```