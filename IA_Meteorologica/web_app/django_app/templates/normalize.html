{% extends 'base.html' %}
{% load static %}

{% block title %}Normalización de Dataset{% endblock %}

{% block extra_css %}
<style>
    .normalization-container {
        max-width: 1400px;
        margin: 0 auto;
    }

    .dataset-header {
        background: rgba(0, 212, 255, 0.05);
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 20px;
        padding: 30px;
        margin-bottom: 30px;
        position: relative;
        overflow: hidden;
    }

    .dataset-header::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(circle, rgba(0, 212, 255, 0.1) 0%, transparent 70%);
        animation: rotate 20s linear infinite;
    }

    .dataset-info {
        position: relative;
        z-index: 1;
    }

    .dataset-stats {
        display: flex;
        gap: 30px;
        margin-top: 20px;
    }

    .stat-item {
        text-align: center;
    }

    .stat-value {
        font-size: 2rem;
        font-weight: 700;
        color: var(--primary-color);
        text-shadow: var(--neon-glow);
    }

    .stat-label {
        color: rgba(240, 249, 255, 0.6);
        font-size: 0.9rem;
    }

    .variables-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }

    .variable-card {
        background: rgba(0, 212, 255, 0.05);
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 15px;
        padding: 20px;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
    }

    .variable-card:hover {
        transform: translateY(-5px);
        box-shadow: var(--neon-glow);
        border-color: var(--primary-color);
    }

    .variable-card::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(circle, rgba(0, 212, 255, 0.05) 0%, transparent 70%);
        transition: all 0.3s ease;
        opacity: 0;
    }

    .variable-card:hover::before {
        opacity: 1;
    }

    .variable-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        position: relative;
        z-index: 1;
    }

    .variable-name {
        font-size: 1.2rem;
        font-weight: 600;
        color: var(--primary-color);
    }

    .variable-type {
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 0.8rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .type-numeric {
        background: rgba(0, 212, 255, 0.2);
        color: #00d4ff;
        border: 1px solid rgba(0, 212, 255, 0.4);
    }

    .type-text {
        background: rgba(255, 0, 255, 0.2);
        color: #ff00ff;
        border: 1px solid rgba(255, 0, 255, 0.4);
    }

    .type-unknown {
        background: rgba(255, 165, 0, 0.2);
        color: #ffa500;
        border: 1px solid rgba(255, 165, 0, 0.4);
    }

    .variable-stats {
        font-size: 0.85rem;
        color: rgba(240, 249, 255, 0.7);
        margin-bottom: 15px;
        line-height: 1.6;
        position: relative;
        z-index: 1;
    }

    .normalization-select {
        width: 100%;
        padding: 10px;
        background: rgba(15, 17, 20, 0.8);
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 8px;
        color: var(--light-color);
        font-size: 0.9rem;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        z-index: 1;
    }

    .normalization-select:hover {
        border-color: var(--primary-color);
        box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
    }

    .normalization-select:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: var(--neon-glow);
    }

    .normalization-select option {
        background: var(--dark-color);
        padding: 10px;
    }

    .normalization-select optgroup {
        font-weight: bold;
        color: var(--primary-color);
    }

    .keep-original-container {
        margin-top: 10px;
        margin-bottom: 5px;
        position: relative;
        z-index: 1;
    }

    .keep-original-label {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        color: var(--light-color);
        font-size: 0.9rem;
        transition: all 0.3s ease;
    }

    .keep-original-label:hover {
        color: var(--primary-color);
    }

    .keep-original-checkbox {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--primary-color);
    }

    .preview-btn {
        margin-top: 10px;
        width: 100%;
        padding: 8px;
        background: transparent;
        border: 1px solid rgba(0, 212, 255, 0.3);
        color: var(--primary-color);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.85rem;
        position: relative;
        z-index: 1;
    }

    .preview-btn:hover {
        background: rgba(0, 212, 255, 0.1);
        border-color: var(--primary-color);
        box-shadow: var(--neon-glow);
    }

    .control-panel {
        background: rgba(0, 212, 255, 0.05);
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 20px;
        padding: 30px;
        margin-bottom: 30px;
        position: sticky;
        top: 20px;
    }

    .control-title {
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--primary-color);
        margin-bottom: 20px;
        text-shadow: var(--neon-glow);
    }

    .control-group {
        margin-bottom: 20px;
    }

    .control-label {
        display: block;
        font-size: 0.9rem;
        color: rgba(240, 249, 255, 0.8);
        margin-bottom: 8px;
    }

    .dataset-name-input {
        width: 100%;
        padding: 10px;
        background: rgba(15, 17, 20, 0.8);
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 8px;
        color: var(--light-color);
        font-size: 0.9rem;
        transition: all 0.3s ease;
    }

    .dataset-name-input:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: var(--neon-glow);
    }

    .apply-btn {
        width: 100%;
        padding: 12px 24px;
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .apply-btn:hover {
        transform: translateY(-2px);
        box-shadow: var(--neon-glow-intense);
    }

    .apply-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .conversion-container {
        margin: 15px 0;
        padding: 15px;
        background: rgba(147, 51, 234, 0.1);
        border: 1px solid rgba(147, 51, 234, 0.3);
        border-radius: 10px;
        animation: fadeIn 0.3s ease;
    }
    
    .conversion-select {
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(0, 212, 255, 0.3);
        color: var(--light-color);
        padding: 8px 12px;
        border-radius: 5px;
        transition: all 0.3s ease;
    }
    
    .conversion-select:hover {
        border-color: var(--primary-color);
        box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
    }
    
    .conversion-select:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
    }

    .normalized-copies {
        margin-top: 30px;
    }

    .copies-title {
        font-size: 1.2rem;
        font-weight: 600;
        color: var(--primary-color);
        margin-bottom: 15px;
    }

    .copy-list {
        background: rgba(15, 17, 20, 0.5);
        border-radius: 10px;
        padding: 10px;
    }

    .copy-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        border-bottom: 1px solid rgba(0, 212, 255, 0.1);
        transition: all 0.3s ease;
    }

    .copy-item:last-child {
        border-bottom: none;
    }

    .copy-item:hover {
        background: rgba(0, 212, 255, 0.05);
    }

    .copy-name {
        font-size: 0.9rem;
        color: var(--light-color);
    }

    .copy-date {
        font-size: 0.8rem;
        color: rgba(240, 249, 255, 0.5);
    }

    .copy-actions {
        display: flex;
        gap: 10px;
    }

    .copy-btn {
        padding: 6px 12px;
        background: transparent;
        border: 1px solid rgba(0, 212, 255, 0.3);
        color: var(--primary-color);
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.8rem;
    }

    .copy-btn:hover {
        background: rgba(0, 212, 255, 0.1);
        border-color: var(--primary-color);
    }

    .loading-spinner {
        display: none;
        text-align: center;
        padding: 50px;
    }

    .spinner {
        border: 3px solid rgba(0, 212, 255, 0.1);
        border-top: 3px solid var(--primary-color);
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
        margin: 0 auto;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .preview-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        overflow-y: auto;
    }

    .preview-content {
        max-width: 800px;
        margin: 50px auto;
        background: var(--dark-color);
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 20px;
        padding: 30px;
        position: relative;
    }

    .preview-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
    }

    .preview-title {
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--primary-color);
    }

    .close-preview {
        background: transparent;
        border: none;
        color: var(--light-color);
        font-size: 1.5rem;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .close-preview:hover {
        color: var(--primary-color);
    }

    .preview-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
    }

    .preview-table-container {
        border: 1px solid rgba(0, 212, 255, 0.2);
        border-radius: 8px;
        overflow: hidden;
        margin-bottom: 20px;
    }

    .preview-table-container::-webkit-scrollbar {
        width: 10px;
    }

    .preview-table-container::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.3);
    }

    .preview-table-container::-webkit-scrollbar-thumb {
        background: rgba(0, 212, 255, 0.5);
        border-radius: 5px;
    }

    .preview-table-container::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 212, 255, 0.7);
    }

    .preview-table th,
    .preview-table td {
        padding: 10px;
        text-align: left;
        border-bottom: 1px solid rgba(0, 212, 255, 0.1);
    }

    .preview-table th {
        background: rgba(0, 212, 255, 0.1);
        color: var(--primary-color);
        font-weight: 600;
    }

    .preview-table thead[style*="sticky"] th {
        background: var(--dark-color);
        border-bottom: 2px solid rgba(0, 212, 255, 0.3);
    }

    .preview-table tr:hover {
        background: rgba(0, 212, 255, 0.05);
    }

    .stats-comparison {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-top: 20px;
    }

    .stats-box {
        background: rgba(0, 212, 255, 0.05);
        border: 1px solid rgba(0, 212, 255, 0.2);
        border-radius: 10px;
        padding: 15px;
    }

    .stats-box h4 {
        color: var(--primary-color);
        margin-bottom: 10px;
    }

    .stat-row {
        display: flex;
        justify-content: space-between;
        padding: 5px 0;
        font-size: 0.9rem;
    }

    .stat-row label {
        color: rgba(240, 249, 255, 0.7);
    }

    .stat-row value {
        color: var(--light-color);
        font-weight: 500;
    }
    
    /* Estilos para el modal de progreso */
    .progress-container {
        color: var(--light-color);
    }
    
    .progress {
        overflow: visible;
    }
    
    .progress-bar {
        position: relative;
        font-weight: 600;
        font-size: 0.9rem;
    }
    
    #progressLog {
        scrollbar-width: thin;
        scrollbar-color: rgba(0, 212, 255, 0.5) rgba(0, 0, 0, 0.3);
    }
    
    #progressLog::-webkit-scrollbar {
        width: 8px;
    }
    
    #progressLog::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.3);
    }
    
    #progressLog::-webkit-scrollbar-thumb {
        background-color: rgba(0, 212, 255, 0.5);
        border-radius: 4px;
    }
    
    #progressLog::-webkit-scrollbar-thumb:hover {
        background-color: rgba(0, 212, 255, 0.8);
    }
    
    .modal-content {
        animation: modalGlow 3s ease-in-out infinite alternate;
    }
    
    @keyframes modalGlow {
        0% { box-shadow: 0 0 20px rgba(0, 212, 255, 0.3); }
        100% { box-shadow: 0 0 40px rgba(0, 212, 255, 0.5); }
    }
    
    .steps-graph {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 10px;
        padding: 20px;
        border: 1px solid rgba(0, 212, 255, 0.2);
    }
    
    /* Estilos para creación de funciones personalizadas */
    .custom-function-btn {
        background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-bottom: 20px;
        font-weight: 600;
        width: 100%;
    }
    
    .custom-function-btn:hover {
        transform: translateY(-2px);
        box-shadow: var(--neon-glow);
    }
    
    .custom-function-modal .modal-content {
        background: var(--dark-color);
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 20px;
    }
    
    .custom-function-modal .modal-header {
        border-bottom: 1px solid rgba(0, 212, 255, 0.3);
    }
    
    .custom-function-modal .modal-footer {
        border-top: 1px solid rgba(0, 212, 255, 0.3);
    }
    
    .function-type-selector {
        display: flex;
        gap: 15px;
        margin-bottom: 20px;
    }
    
    .function-type-option {
        flex: 1;
        padding: 15px;
        border: 2px solid rgba(0, 212, 255, 0.3);
        border-radius: 10px;
        cursor: pointer;
        text-align: center;
        transition: all 0.3s ease;
    }
    
    .function-type-option:hover {
        border-color: var(--primary-color);
        background: rgba(0, 212, 255, 0.05);
    }
    
    .function-type-option.active {
        border-color: var(--primary-color);
        background: rgba(0, 212, 255, 0.1);
        box-shadow: var(--neon-glow);
    }
    
    .code-editor {
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 8px;
        padding: 15px;
        font-family: 'Consolas', 'Monaco', monospace;
        min-height: 500px;
        width: 100%;
        color: #f0f9ff;
        overflow-x: auto;
        resize: vertical;
    }
    
    .code-editor:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: var(--neon-glow);
    }
    
    .test-section {
        background: rgba(0, 212, 255, 0.05);
        border: 1px solid rgba(0, 212, 255, 0.2);
        border-radius: 10px;
        padding: 20px;
        margin-top: 20px;
    }
    
    .test-input {
        width: 100%;
        padding: 10px;
        background: rgba(15, 17, 20, 0.8);
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 8px;
        color: var(--light-color);
        margin-bottom: 10px;
    }
    
    .test-result {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        padding: 15px;
        font-family: monospace;
        white-space: pre-wrap;
        word-break: break-all;
        max-height: 400px;
        overflow-y: auto;
        animation: fadeIn 0.3s ease-in;
    }
    
    .normalization-layers {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-bottom: 10px;
    }
    
    .normalization-layer {
        padding: 10px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        border: 1px solid rgba(0, 212, 255, 0.2);
        position: relative;
    }
    
    .normalization-layer > div:first-child {
        margin-bottom: 8px;
    }
    
    .layer-controls {
        margin-top: 10px;
        text-align: center;
        position: relative;
        z-index: 10;
    }
    
    .add-layer-btn {
        background: rgba(0, 212, 255, 0.1);
        border: 1px solid rgba(0, 212, 255, 0.3);
        color: var(--primary-color);
        padding: 8px 16px;
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.9rem;
        position: relative;
        z-index: 100;
        display: inline-block;
        pointer-events: auto;
    }
    
    .add-layer-btn:hover {
        background: rgba(0, 212, 255, 0.2);
        border-color: var(--primary-color);
        box-shadow: var(--neon-glow);
    }
    
    .remove-layer-btn {
        background: transparent;
        border: none;
        color: #ff4444;
        cursor: pointer;
        padding: 5px;
        transition: all 0.3s ease;
        position: relative;
        z-index: 100;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
    }
    
    .remove-layer-btn:hover {
        color: #ff6666;
        transform: scale(1.1);
    }
    
    .remove-layer-btn:active {
        transform: scale(0.95);
    }
    
    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    .test-result.success {
        border: 1px solid rgba(0, 255, 0, 0.3);
        color: #00ff00;
    }
    
    .test-result.error {
        border: 1px solid rgba(255, 0, 0, 0.3);
        color: #ff6b6b;
    }
    
    .test-result code {
        background: rgba(0, 212, 255, 0.1);
        padding: 2px 6px;
        border-radius: 4px;
        color: var(--primary-color);
    }
    
    .test-result .badge {
        font-size: 0.85rem;
        font-weight: normal;
    }
    
    .test-result-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
    }
    
    .compatibility-indicator {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.75rem;
        margin-left: 8px;
        background: rgba(0, 212, 255, 0.1);
        border: 1px solid rgba(0, 212, 255, 0.3);
        color: var(--primary-color);
    }
    
    .compatibility-indicator.numeric {
        background: rgba(0, 212, 255, 0.1);
        border-color: rgba(0, 212, 255, 0.3);
        color: #00d4ff;
    }
    
    .compatibility-indicator.text {
        background: rgba(255, 204, 0, 0.1);
        border-color: rgba(255, 204, 0, 0.3);
        color: #ffcc00;
    }
    
    .compatibility-arrow {
        display: inline-block;
        margin: 0 5px;
        color: var(--primary-color);
        font-size: 1.2rem;
    }
    
    .transformation-steps {
        margin-bottom: 20px;
    }
    
    .transformation-step {
        background: rgba(0, 212, 255, 0.05);
        border: 1px solid rgba(0, 212, 255, 0.2);
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
        position: relative;
        overflow: hidden;
    }
    
    .transformation-step::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 3px;
        background: linear-gradient(90deg, var(--primary-color), transparent);
    }
    
    .step-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 15px;
    }
    
    .step-title {
        color: var(--primary-color);
        font-size: 1.1rem;
        font-weight: 600;
    }
    
    .step-method {
        background: rgba(0, 212, 255, 0.1);
        padding: 4px 12px;
        border-radius: 15px;
        color: var(--primary-color);
        font-size: 0.9rem;
    }
    
    .preview-comparison {
        display: grid;
        grid-template-columns: 1fr auto 1fr;
        gap: 20px;
        align-items: start;
    }
    
    .preview-arrow {
        display: flex;
        align-items: center;
        justify-content: center;
        padding-top: 30px;
        color: var(--primary-color);
        font-size: 2rem;
    }
    
    .preview-column {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        padding: 15px;
    }
    
    .preview-column h6 {
        color: rgba(240, 249, 255, 0.8);
        margin-bottom: 10px;
        font-size: 0.9rem;
        text-transform: uppercase;
    }
    
    .preview-values {
        font-family: 'Fira Code', monospace;
        line-height: 1.6;
    }
    
    .preview-value {
        padding: 2px 8px;
        margin: 2px 0;
        background: rgba(0, 212, 255, 0.05);
        border-radius: 4px;
        transition: all 0.2s ease;
    }
    
    .preview-value:hover {
        background: rgba(0, 212, 255, 0.1);
        transform: translateX(5px);
    }
    
    .step-info {
        margin-top: 15px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 6px;
        font-size: 0.85rem;
    }
    
    .step-info i {
        margin-right: 5px;
    }
    
    .test-result-table th,
    .test-result-table td {
        padding: 8px;
        text-align: left;
        border-bottom: 1px solid rgba(0, 212, 255, 0.2);
    }
    
    .test-result-table th {
        background: rgba(0, 212, 255, 0.1);
        color: var(--primary-color);
        font-weight: 600;
        position: sticky;
        top: 0;
        z-index: 10;
    }
    
    .test-result-table tr:hover {
        background: rgba(0, 212, 255, 0.05);
    }
    
    .test-buttons {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
    }
    
    /* Estilos para gestión de funciones */
    .functions-list {
        max-height: 500px;
        overflow-y: auto;
    }
    
    .function-item {
        background: rgba(0, 212, 255, 0.05);
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 15px;
        transition: all 0.3s ease;
    }
    
    .function-item:hover {
        background: rgba(0, 212, 255, 0.1);
        border-color: var(--primary-color);
    }
    
    .function-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }
    
    .function-name {
        font-weight: 600;
        color: var(--primary-color);
        font-size: 1.1rem;
    }
    
    .function-type {
        background: rgba(0, 212, 255, 0.2);
        padding: 2px 10px;
        border-radius: 15px;
        font-size: 0.8rem;
        color: var(--light-color);
    }
    
    .function-actions {
        display: flex;
        gap: 10px;
    }
    
    .function-actions button {
        padding: 5px 10px;
        background: transparent;
        border: 1px solid rgba(0, 212, 255, 0.3);
        color: var(--primary-color);
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.85rem;
    }
    
    .function-actions button:hover {
        background: rgba(0, 212, 255, 0.1);
        border-color: var(--primary-color);
    }
    
    .function-actions button.delete-btn {
        border-color: rgba(255, 107, 107, 0.5);
        color: #ff6b6b;
    }
    
    .function-actions button.delete-btn:hover {
        background: rgba(255, 107, 107, 0.1);
        border-color: #ff6b6b;
    }
    
    /* Estilos para el checkbox global de columna */
    .keep-original-container {
        animation: fadeIn 0.3s ease-in;
    }
    
    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    /* Hacer el checkbox global más prominente */
    .variable-card .keep-original-container[id^="keep-original-"]:not([id*="-0"]):not([id*="-1"]):not([id*="-2"]):not([id*="-3"]):not([id*="-4"]):not([id*="-5"]):not([id*="-6"]):not([id*="-7"]):not([id*="-8"]):not([id*="-9"]) {
        background: linear-gradient(135deg, rgba(0, 212, 255, 0.1) 0%, rgba(147, 51, 234, 0.05) 100%) !important;
        border: 2px solid rgba(0, 212, 255, 0.4) !important;
        box-shadow: 0 2px 10px rgba(0, 212, 255, 0.2);
        margin-bottom: 15px;
    }
    
    .variable-card .keep-original-container[id^="keep-original-"]:not([id*="-0"]):not([id*="-1"]):not([id*="-2"]):not([id*="-3"]):not([id*="-4"]):not([id*="-5"]):not([id*="-6"]):not([id*="-7"]):not([id*="-8"]):not([id*="-9"]):hover {
        border-color: rgba(0, 212, 255, 0.6) !important;
        box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
    }
    
    .keep-original-label {
        cursor: pointer;
        transition: all 0.3s ease;
    }
    
    .keep-original-label:hover {
        color: var(--primary-color) !important;
    }
    
    .keep-original-checkbox {
        width: 18px;
        height: 18px;
        cursor: pointer;
    }
</style>
{% endblock %}

{% block content %}
<div class="normalization-container">
    <div class="page-header">
        <h1>Normalización de Dataset</h1>
        <p>Normaliza tu dataset variable por variable con métodos específicos para cada tipo de dato</p>
    </div>

    <div class="dataset-header">
        <div class="dataset-info">
            <h2 id="dataset-name">Cargando dataset...</h2>
            <div class="dataset-stats">
                <div class="stat-item">
                    <div class="stat-value" id="dataset-rows">-</div>
                    <div class="stat-label">Filas</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="dataset-cols">-</div>
                    <div class="stat-label">Columnas</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="normalized-count">0</div>
                    <div class="stat-label">Normalizadas</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Botones para funciones personalizadas -->
    <div class="d-flex gap-2 mb-3">
        <button class="custom-function-btn" onclick="openCustomFunctionModal()">
            <i class="bi bi-code-slash"></i> Crear Función de Normalización Personalizada
        </button>
        <button class="custom-function-btn" onclick="openManageFunctionsModal()">
            <i class="bi bi-gear"></i> Gestionar Funciones Existentes
        </button>
    </div>

    <div class="row">
        <div class="col-md-8">
            <h3 class="mb-4">Variables del Dataset</h3>
            <div class="variables-grid" id="variables-grid">
                <div class="loading-spinner">
                    <div class="spinner"></div>
                    <p class="mt-3">Cargando variables...</p>
                </div>
            </div>
        </div>

        <div class="col-md-4">
            <div class="control-panel">
                <h3 class="control-title">Control de Normalización</h3>
                
                <div class="control-group">
                    <label class="control-label">Nombre del dataset normalizado:</label>
                    <input type="text" class="dataset-name-input" id="new-dataset-name" 
                           placeholder="Se generará automáticamente">
                </div>
                
                <div class="control-group">
                    <label class="control-label">Descripción corta: <small class="text-muted" id="normShortCharCount">(0/80)</small></label>
                    <input type="text" class="dataset-name-input" id="new-dataset-short-description" 
                           placeholder="Descripción breve para las tarjetas..."
                           maxlength="80" oninput="updateNormShortCharCount()">
                </div>
                
                <div class="control-group">
                    <label class="control-label">Descripción detallada (opcional):</label>
                    <textarea class="dataset-name-input" id="new-dataset-long-description" 
                              rows="3" placeholder="Describa detalladamente los cambios realizados en la normalización..."></textarea>
                </div>

                <div class="control-group">
                    <label class="control-label">Variables seleccionadas:</label>
                    <div id="selected-count">0 variables seleccionadas</div>
                </div>

                <button class="apply-btn" id="apply-normalization" disabled>
                    <i class="bi bi-check-circle"></i> Aplicar Normalización
                </button>

                <div class="normalized-copies" id="normalized-copies">
                    <h4 class="copies-title">Copias Normalizadas</h4>
                    <div class="copy-list" id="copy-list">
                        <p class="text-muted text-center">No hay copias normalizadas</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Modal de previsualización -->
<div class="preview-modal" id="preview-modal">
    <div class="preview-content">
        <div class="preview-header">
            <h3 class="preview-title" id="preview-title">Previsualización</h3>
            <button class="close-preview" onclick="closePreview()">&times;</button>
        </div>
        <div id="preview-body">
            <!-- Content will be dynamically inserted here -->
        </div>
    </div>
</div>

<!-- Modal de progreso de normalización -->
<div class="modal fade" id="progressModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content" style="background: var(--dark-color); border: 1px solid rgba(0, 212, 255, 0.3);">
            <div class="modal-header" style="border-bottom: 1px solid rgba(0, 212, 255, 0.3);">
                <h5 class="modal-title" style="color: var(--primary-color);">
                    <i class="bi bi-gear-wide-connected"></i> Proceso de Normalización
                </h5>
            </div>
            <div class="modal-body">
                <div class="progress-container">
                    <div class="overall-progress mb-4">
                        <h6 style="color: var(--light-color);">Progreso General</h6>
                        <div class="progress" style="height: 30px; background: rgba(0, 212, 255, 0.1);">
                            <div id="overallProgressBar" class="progress-bar progress-bar-striped progress-bar-animated" 
                                 style="background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));"
                                 role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                                <span id="overallProgressText">0%</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="current-step mb-4">
                        <h6 style="color: var(--light-color);">Paso Actual</h6>
                        <div class="step-info" style="background: rgba(0, 212, 255, 0.05); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 212, 255, 0.2);">
                            <div id="currentStepText" style="color: var(--primary-color); font-weight: 600;">Preparando normalización...</div>
                            <div id="currentStepDetails" style="color: rgba(240, 249, 255, 0.7); font-size: 0.9rem; margin-top: 5px;"></div>
                        </div>
                    </div>
                    
                    <div class="steps-visualization mb-4">
                        <h6 style="color: var(--light-color);">Pasos del Proceso</h6>
                        <div class="steps-graph" style="position: relative; height: 300px;">
                            <canvas id="progressChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="steps-log">
                        <h6 style="color: var(--light-color);">Registro de Actividad</h6>
                        <div id="progressLog" style="background: rgba(0, 0, 0, 0.3); padding: 15px; border-radius: 10px; height: 150px; overflow-y: auto; font-family: monospace; font-size: 0.85rem;">
                            <!-- Los logs aparecerán aquí -->
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="border-top: 1px solid rgba(0, 212, 255, 0.3);">
                <button type="button" class="btn btn-danger" id="cancelNormalization">
                    <i class="bi bi-x-circle"></i> Cancelar Proceso
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Modal para Gestionar Funciones Existentes -->
<div class="modal fade" id="manageFunctionsModal" tabindex="-1">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" style="color: var(--primary-color);">
                    <i class="bi bi-gear"></i> Gestionar Funciones Personalizadas
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div id="functionsList" class="functions-list">
                    <!-- Las funciones se cargarán aquí -->
                    <div class="text-center">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Cargando...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Modal de creación de función personalizada -->
<div class="modal fade custom-function-modal" id="customFunctionModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" style="color: var(--primary-color);">
                    <i class="bi bi-code-slash"></i> Crear Función de Normalización Personalizada
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <!-- Selector de tipo de objetivo -->
                <div class="mb-3">
                    <label class="form-label" style="color: var(--light-color);">Tipo de variable objetivo:</label>
                    <div class="function-type-selector">
                        <div class="function-type-option active" data-type="numeric" onclick="selectFunctionType('numeric')">
                            <i class="bi bi-123" style="font-size: 2rem; color: var(--primary-color);"></i>
                            <h6 style="margin-top: 10px;">Numérica</h6>
                            <small>Para valores numéricos</small>
                        </div>
                        <div class="function-type-option" data-type="text" onclick="selectFunctionType('text')">
                            <i class="bi bi-fonts" style="font-size: 2rem; color: var(--secondary-color);"></i>
                            <h6 style="margin-top: 10px;">Texto</h6>
                            <small>Para valores de texto</small>
                        </div>
                    </div>
                </div>
                
                <!-- Nombre de la función -->
                <div class="mb-3">
                    <label class="form-label" style="color: var(--light-color);">Nombre de la función:</label>
                    <input type="text" class="form-control dataset-name-input" id="functionName" 
                           placeholder="Ej: normalizar_temperatura, codificar_categorias">
                </div>
                
                <!-- Descripción -->
                <div class="mb-3">
                    <label class="form-label" style="color: var(--light-color);">Descripción:</label>
                    <textarea class="form-control dataset-name-input" id="functionDescription" rows="2"
                              placeholder="Describe qué hace tu función de normalización..."></textarea>
                </div>
                
                
                <!-- Nuevas columnas -->
                <div class="mb-3">
                    <label class="form-label" style="color: var(--light-color);">Columnas nuevas a crear:</label>
                    <div class="input-group mb-2">
                        <input type="number" class="form-control" id="numNewColumns" min="1" max="10" value="1" 
                               placeholder="Número de columnas" onchange="updateNewColumnsInputs()">
                        <span class="input-group-text">columnas</span>
                    </div>
                    <div id="newColumnsContainer">
                        <!-- Los inputs de nombres de columnas se generarán dinámicamente aquí -->
                    </div>
                </div>
                
                <!-- Editor de código -->
                <div class="mb-3">
                    <label class="form-label" style="color: var(--light-color);">Código de la función:</label>
                    <div class="alert alert-info" style="background: rgba(0, 212, 255, 0.1); border: 1px solid rgba(0, 212, 255, 0.3); color: var(--light-color);">
                        <i class="bi bi-info-circle"></i> La función debe recibir un parámetro 'value' y retornar el valor normalizado.
                        Para funciones numéricas, también puede recibir 'series' con toda la columna.
                        <br><br>
                        <strong>Módulos disponibles para importar:</strong>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                            <div>
                                <strong style="color: #00d4ff;">Cálculo y Matemáticas:</strong>
                                <ul style="margin-bottom: 0; margin-top: 5px; font-size: 0.9em;">
                                    <li><code>numpy</code> (o <code>np</code>) - Arrays y operaciones numéricas</li>
                                    <li><code>math</code> - Funciones matemáticas básicas</li>
                                    <li><code>statistics</code> - Estadísticas estándar de Python</li>
                                    <li><code>scipy.stats</code> - Distribuciones y tests estadísticos</li>
                                    <li><code>scipy.special</code> - Funciones matemáticas especiales</li>
                                </ul>
                            </div>
                            <div>
                                <strong style="color: #00d4ff;">Procesamiento de Datos:</strong>
                                <ul style="margin-bottom: 0; margin-top: 5px; font-size: 0.9em;">
                                    <li><code>pandas</code> (o <code>pd</code>) - DataFrames y Series</li>
                                    <li><code>sklearn.preprocessing</code> - Normalizadores ML</li>
                                    <li><code>datetime</code>, <code>timezone</code>, <code>timedelta</code> - Fechas</li>
                                    <li><code>re</code> - Expresiones regulares</li>
                                    <li><code>json</code> - Manejo de JSON</li>
                                    <li><code>unicodedata</code> - Normalización Unicode</li>
                                </ul>
                            </div>
                        </div>
                        <div style="margin-top: 10px;">
                            <strong style="color: #00d4ff;">Utilidades:</strong>
                            <ul style="margin-bottom: 0; margin-top: 5px; font-size: 0.9em;">
                                <li><code>collections.Counter</code>, <code>collections.defaultdict</code> - Estructuras de datos</li>
                                <li><code>itertools</code> - Herramientas de iteración</li>
                                <li><code>functools</code> - Herramientas funcionales</li>
                            </ul>
                        </div>
                        <div style="margin-top: 10px; padding: 10px; background: rgba(255, 107, 107, 0.1); border-radius: 5px;">
                            <strong>Ejemplo de uso:</strong>
                            <pre style="margin: 0; font-size: 0.85em;"><code>import numpy as np
from sklearn.preprocessing import StandardScaler

def normalize(value, series=None):
    # Tu código aquí
    return np.log1p(value)  # Ejemplo: log(1+x)</code></pre>
                        </div>
                    </div>
                    <textarea class="code-editor" id="functionCode" placeholder="def normalize(value):
    # Tu código aquí
    return normalized_value"></textarea>
                </div>
                
                <!-- Sección de prueba -->
                <div class="test-section">
                    <h6 style="color: var(--primary-color);">Probar función</h6>
                    
                    <!-- Opción 1: Valor manual -->
                    <div class="mb-4" style="border: 1px solid rgba(0, 212, 255, 0.2); border-radius: 8px; padding: 15px;">
                        <label class="form-label" style="color: var(--light-color);">
                            <i class="bi bi-pencil"></i> Opción 1: Ingresar valor de prueba manual
                        </label>
                        <input type="text" class="test-input" id="testValue" 
                               placeholder="Escribe aquí un valor para probar tu función">
                        <button class="btn btn-sm btn-primary mt-2" onclick="testWithManualValue()">
                            <i class="bi bi-play-circle"></i> Probar con este valor
                        </button>
                        <div id="manualTestResult" class="test-result mt-3" style="display: none;"></div>
                    </div>
                    
                    <!-- Opción 2: Columna del dataset -->
                    <div class="mb-3" style="border: 1px solid rgba(0, 212, 255, 0.2); border-radius: 8px; padding: 15px;">
                        <label class="form-label" style="color: var(--light-color);">
                            <i class="bi bi-table"></i> Opción 2: Probar con valores de una columna
                        </label>
                        <select class="form-select test-input" id="columnSelector" 
                                onchange="updateDatasetValues()"
                                style="background: rgba(15, 17, 20, 0.8); border: 1px solid rgba(0, 212, 255, 0.3); color: var(--light-color);">
                            <option value="">Seleccionar columna del dataset...</option>
                        </select>
                        <div id="columnTestButtons" style="display: none;" class="mt-2">
                            <button class="btn btn-sm btn-success" onclick="testFirst20Values()" id="test20Btn">
                                <i class="bi bi-lightning"></i> Probar primeros 20 valores
                            </button>
                            <button class="btn btn-sm btn-info" onclick="testAllUniqueValues()" id="testUniqueBtn">
                                <i class="bi bi-list-check"></i> Probar todos los valores únicos
                            </button>
                        </div>
                        <div id="columnTestResult" class="test-result mt-3" style="display: none;"></div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                <button type="button" class="btn btn-primary" onclick="saveCustomFunction()">
                    <i class="bi bi-save"></i> Guardar Función
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
    const datasetId = {{ dataset_id }};
    let datasetInfo = null;
    let normalizationConfig = {};
    let normalizedCount = 0;
    let selectedFunctionType = 'numeric';
    let detectedColumnNames = [];

    // Función para obtener el token CSRF
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    
    document.addEventListener('DOMContentLoaded', function() {
        console.log('normalize.html script loaded');
        loadDatasetInfo();
        
        // Verificar que las funciones globales estén disponibles
        console.log('window.editFunction:', typeof window.editFunction);
        console.log('window.deleteFunction:', typeof window.deleteFunction);
        
        // Añadir soporte para Tab en el editor de código
        const codeEditor = document.getElementById('functionCode');
        if (codeEditor) {
            codeEditor.addEventListener('keydown', function(e) {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    const value = this.value;
                    
                    // Insertar 4 espacios donde está el cursor
                    this.value = value.substring(0, start) + '    ' + value.substring(end);
                    
                    // Mover el cursor después de los espacios insertados
                    this.selectionStart = this.selectionEnd = start + 4;
                }
            });
        }
    });

    async function loadDatasetInfo() {
        try {
            // Agregar timestamp para evitar cache
            const timestamp = new Date().getTime();
            const url = `/api/datasets/${datasetId}/normalization/?t=${timestamp}`;
            console.log('Fetching from URL:', url);
            
            const response = await fetch(url, {
                cache: 'no-store'
            });
            
            console.log('Response status:', response.status);
            console.log('Response ok:', response.ok);
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error('Error response:', errorText);
                throw new Error(`Error loading dataset info: ${response.status} ${response.statusText}`);
            }
            
            const responseText = await response.text();
            console.log('Raw response:', responseText);
            
            try {
                datasetInfo = JSON.parse(responseText);
                console.log('Parsed dataset info:', datasetInfo);
            } catch (parseError) {
                console.error('Error parsing JSON:', parseError);
                throw new Error('Invalid JSON response from server');
            }
            
            // Actualizar información del dataset
            const nameElement = document.getElementById('dataset-name');
            const rowsElement = document.getElementById('dataset-rows');
            const colsElement = document.getElementById('dataset-cols');
            
            if (nameElement) nameElement.textContent = datasetInfo.dataset.name;
            else console.error('dataset-name element not found');
            
            if (rowsElement) rowsElement.textContent = datasetInfo.dataset.shape[0].toLocaleString();
            else console.error('dataset-rows element not found');
            
            if (colsElement) colsElement.textContent = datasetInfo.dataset.shape[1];
            else console.error('dataset-cols element not found');
            
            // Sugerir nombre para el dataset normalizado
            // Contar cuántas normalizaciones existen
            const normalizedCount = datasetInfo.normalized_copies ? datasetInfo.normalized_copies.length : 0;
            const nextNumber = normalizedCount + 1;
            document.getElementById('new-dataset-name').placeholder = 
                `${datasetInfo.dataset.name}_normalizacion_${nextNumber}`;
            
            // Renderizar variables
            renderVariables();
            
            // Cargar copias normalizadas
            renderNormalizedCopies();
            
        } catch (error) {
            console.error('Error loading dataset info:', error);
            console.error('Error details:', error.message);
            console.error('Stack trace:', error.stack);
            showNotification('Error al cargar información del dataset: ' + error.message, 'error');
        }
    }

    function getConversionOptions(outputType) {
        // Get conversion options based on the output type
        if (!datasetInfo.conversion_options) {
            return [];
        }
        
        // For now, we'll return same-type conversions
        // In the future, we could add cross-type conversions
        const key = `${outputType}_to_${outputType}`;
        return datasetInfo.conversion_options[key] || [];
    }
    
    function getConversionLabel(conversionValue) {
        // Find the conversion label from all conversion options
        if (!datasetInfo.conversion_options) {
            return conversionValue;
        }
        
        for (const key in datasetInfo.conversion_options) {
            const options = datasetInfo.conversion_options[key];
            for (const option of options) {
                if (option.value === conversionValue) {
                    return option.label;
                }
            }
        }
        
        return conversionValue;
    }
    
    function getOutputDataType(column, layerIndex) {
        // Get the output data type for a specific layer
        if (!normalizationConfig[column] || !normalizationConfig[column][layerIndex]) {
            // Return original column dtype if no method selected
            return datasetInfo.normalization_info[column]?.dtype || 'unknown';
        }
        
        const step = normalizationConfig[column][layerIndex];
        const method = step.method;
        const conversion = step.conversion;
        
        // If there's a conversion, that determines the output type
        if (conversion) {
            // Extract dtype from conversion (e.g., TO_FLOAT64 -> float64)
            if (conversion === 'TO_FLOAT64') return 'float64';
            if (conversion === 'TO_FLOAT32') return 'float32';
            if (conversion === 'TO_INT64') return 'Int64';
            if (conversion === 'TO_INT32') return 'Int32';
            if (conversion === 'TO_INT16') return 'Int16';
            if (conversion === 'TO_STRING') return 'object';
            if (conversion === 'TO_NUMERIC') return 'float64';  // Default numeric conversion
        }
        
        // Otherwise, get the output dtype from the method
        const methodInfo = [...datasetInfo.normalization_info[column].primary_methods, 
                           ...datasetInfo.normalization_info[column].secondary_methods]
                           .find(m => m.value === method);
        
        return methodInfo?.output_dtype || 'unknown';
    }
    
    function updateLayerOutputTypeIndicator(column, layerIndex, method) {
        const escapedColumn = column.replace(/['"\\]/g, '\\$&').replace(/\s/g, '_');
        const outputIndicator = document.getElementById(`output-type-${escapedColumn}-${layerIndex}`);
        
        if (!outputIndicator) return;
        
        if (!method) {
            outputIndicator.style.display = 'none';
            return;
        }
        
        // Check if it's a custom function
        if (method.startsWith('CUSTOM_')) {
            // For custom functions, try to get more specific info
            fetch(`/api/custom-normalization-functions/${method.replace('CUSTOM_', '')}/info/`)
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.function) {
                        const func = data.function;
                        let outputText = '';
                        
                        if (func.new_columns && func.new_columns.length > 0) {
                            // Store the function info for later use
                            outputIndicator.dataset.customFunctionId = method.replace('CUSTOM_', '');
                            outputIndicator.dataset.expectedColumns = JSON.stringify(func.new_columns);
                            
                            outputText = `
                                <i class="bi bi-arrow-right" style="opacity: 0.7;"></i>
                                Salida: ${func.new_columns.length} columna${func.new_columns.length > 1 ? 's' : ''}
                                <button class="btn btn-sm btn-link p-0 ms-1" style="color: var(--primary-color);" 
                                        onclick="showColumnDetails('${column.replace(/'/g, "\\'")}', ${layerIndex})"
                                        title="Ver detalles de columnas">
                                    <i class="bi bi-eye"></i>
                                </button>
                                <br>
                                <span style="font-size: 0.75rem; opacity: 0.8;">
                                    ${func.new_columns.slice(0, 2).join(', ')}${func.new_columns.length > 2 ? '...' : ''}
                                </span>
                            `;
                        } else {
                            outputText = `
                                <i class="bi bi-arrow-right" style="opacity: 0.7;"></i>
                                Salida: ${func.function_type === 'numeric' ? 'Numérico' : 'Texto'}
                            `;
                        }
                        
                        outputIndicator.innerHTML = outputText;
                        outputIndicator.style.display = 'inline-block';
                        outputIndicator.style.background = 'rgba(147, 51, 234, 0.2)';
                        outputIndicator.style.borderColor = 'rgba(147, 51, 234, 0.5)';
                        
                        // After setting up the indicator, try to get real column names
                        if (func.new_columns && func.new_columns.length > 0) {
                            // Asynchronously fetch real column names
                            getRealColumnNames(column, layerIndex).then(realNames => {
                                if (realNames && realNames.length > 0) {
                                    outputIndicator.dataset.realColumns = JSON.stringify(realNames);
                                    // Update any existing next layer input selector
                                    updateNextLayerInputSelector(column, layerIndex);
                                }
                            });
                        }
                    }
                })
                .catch(error => {
                    console.error('Error fetching custom function info:', error);
                });
            return;
        }
        
        // Get method info for standard functions
        const info = datasetInfo.normalization_info[column];
        const methodInfo = [...info.primary_methods, ...info.secondary_methods].find(m => m.value === method);
        
        if (methodInfo) {
            const outputType = methodInfo.output_type || 'unknown';
            const outputDType = methodInfo.output_dtype || 'unknown';
            
            outputIndicator.innerHTML = `
                <i class="bi bi-arrow-right" style="opacity: 0.7;"></i>
                Salida: ${outputType === 'numeric' ? 'Numérico' : outputType === 'text' ? 'Texto' : 'Desconocido'}
                ${outputDType !== 'unknown' ? ` (${outputDType})` : ''}
            `;
            outputIndicator.style.display = 'inline-block';
            
            // Update color based on type
            if (outputType === 'numeric') {
                outputIndicator.style.background = 'rgba(0, 212, 255, 0.2)';
                outputIndicator.style.borderColor = 'rgba(0, 212, 255, 0.5)';
            } else if (outputType === 'text') {
                outputIndicator.style.background = 'rgba(255, 107, 107, 0.2)';
                outputIndicator.style.borderColor = 'rgba(255, 107, 107, 0.5)';
            }
        } else {
            outputIndicator.style.display = 'none';
        }
    }
    
    async function getRealColumnNames(column, layerIndex) {
        // Build config up to this layer
        const previewConfig = {};
        if (!normalizationConfig[column] || !Array.isArray(normalizationConfig[column])) {
            return null;
        }
        
        previewConfig[column] = normalizationConfig[column].slice(0, layerIndex + 1).filter(layer => layer && layer.method);
        
        try {
            const response = await fetch(`/api/datasets/${datasetId}/normalization/preview/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    normalization: previewConfig,
                    sample_size: 5  // Small sample just to get column names
                })
            });
            
            if (response.ok) {
                const data = await response.json();
                
                // Extract real column names from the preview
                if (data.preview && data.preview[column]) {
                    const colData = data.preview[column];
                    
                    if (colData.new_columns) {
                        return colData.new_columns;
                    } else if (colData.column_types_info) {
                        return colData.column_types_info.map(info => info.name);
                    }
                }
            }
        } catch (error) {
            console.error('Error fetching real column names:', error);
        }
        
        return null;
    }
    
    async function updateLayerInputTypeFromSelectedColumn(column, layerIndex) {
        const escapedColumn = column.replace(/['"\\]/g, '\\$&').replace(/\s/g, '_');
        const layer = document.querySelector(`#layers-${escapedColumn} [data-layer-index="${layerIndex}"]`);
        if (!layer) return;
        
        const inputIndicator = layer.querySelector('.compatibility-indicator');
        if (!inputIndicator) return;
        
        // Get the selected input column
        const selectedColumn = normalizationConfig[column][layerIndex]?.input_column;
        if (!selectedColumn) return;
        
        // Build config up to previous layer to get column types
        const previewConfig = {};
        previewConfig[column] = normalizationConfig[column].slice(0, layerIndex).filter(layer => layer && layer.method);
        
        try {
            const response = await fetch(`/api/datasets/${datasetId}/normalization/preview/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    normalization: previewConfig,
                    sample_size: 5
                })
            });
            
            if (response.ok) {
                const data = await response.json();
                
                // Use all_column_types for better type detection
                if (data.all_column_types && data.all_column_types[selectedColumn]) {
                    const columnInfo = data.all_column_types[selectedColumn];
                    
                    // Update the input indicator with the correct type
                    let typeClass = 'text';
                    let typeLabel = 'Texto';
                    
                    if (columnInfo.type === 'numeric' || columnInfo.type === 'integer' || columnInfo.type === 'float') {
                        typeClass = 'numeric';
                        typeLabel = 'Numérico';
                    }
                    
                    inputIndicator.className = `compatibility-indicator ${typeClass}`;
                    inputIndicator.textContent = `Entrada: ${typeLabel} (${columnInfo.dtype})`;
                    
                    // Store the type for method filtering
                    layer.dataset.inputType = typeClass;
                    
                    // Update the methods compatibility after setting the type
                    updateLayerMethodsCompatibility(column, layerIndex);
                } else if (data.preview && data.preview[column] && data.preview[column].column_types_info) {
                    // Fallback to old method for backward compatibility
                    const columnInfo = data.preview[column].column_types_info.find(info => info.name === selectedColumn);
                    
                    if (columnInfo) {
                        // Update the input indicator with the correct type
                        let typeClass = 'text';
                        let typeLabel = 'Texto';
                        
                        if (columnInfo.type === 'numeric' || columnInfo.type === 'integer' || columnInfo.type === 'float') {
                            typeClass = 'numeric';
                            typeLabel = 'Numérico';
                        }
                        
                        inputIndicator.className = `compatibility-indicator ${typeClass}`;
                        inputIndicator.textContent = `Entrada: ${typeLabel} (${columnInfo.dtype})`;
                        
                        // Store the type for method filtering
                        layer.dataset.inputType = typeClass;
                        
                        // Update the methods compatibility after setting the type
                        updateLayerMethodsCompatibility(column, layerIndex);
                    }
                }
            }
        } catch (error) {
            console.error('Error updating input type:', error);
        }
    }
    
    function updateLayerMethodsCompatibility(column, layerIndex) {
        const escapedColumn = column.replace(/['"\\]/g, '\\$&').replace(/\s/g, '_');
        const layer = document.querySelector(`#layers-${escapedColumn} [data-layer-index="${layerIndex}"]`);
        if (!layer) return;
        
        const select = layer.querySelector('.normalization-select');
        if (!select) return;
        
        const inputType = layer.dataset.inputType || 'numeric';
        const info = datasetInfo.normalization_info[column];
        
        // Separate all methods by type
        const allMethods = [...info.primary_methods, ...info.secondary_methods];
        
        // Define numeric and text methods
        const numericMethods = allMethods.filter(method => 
            ['MIN_MAX', 'Z_SCORE', 'LSTM_TCN', 'CNN', 'TRANSFORMER', 'TREE'].includes(method.value)
        );
        
        const textMethods = allMethods.filter(method => 
            ['LOWER', 'STRIP', 'ONE_HOT'].includes(method.value)
        );
        
        const customMethods = allMethods.filter(method => 
            method.value.startsWith('CUSTOM_')
        );
        
        // Separate into primary and secondary for each type
        const numericPrimary = numericMethods.filter(m => info.primary_methods.some(pm => pm.value === m.value));
        const numericSecondary = numericMethods.filter(m => info.secondary_methods.some(sm => sm.value === m.value));
        const textPrimary = textMethods.filter(m => info.primary_methods.some(pm => pm.value === m.value));
        const textSecondary = textMethods.filter(m => info.secondary_methods.some(sm => sm.value === m.value));
        const customPrimary = customMethods.filter(m => info.primary_methods.some(pm => pm.value === m.value));
        const customSecondary = customMethods.filter(m => info.secondary_methods.some(sm => sm.value === m.value));
        
        const currentValue = select.value;
        
        // Update select options showing all methods organized by type - all enabled
        select.innerHTML = `
            <option value="">Sin normalizar</option>
            ${inputType === 'numeric' ? `
                ${numericPrimary.length > 0 ? `
                    <optgroup label="Métodos numéricos recomendados">
                        ${numericPrimary.map(method => 
                            `<option value="${method.value}" title="${method.description}">${method.label}</option>`
                        ).join('')}
                    </optgroup>
                ` : ''}
                ${numericSecondary.length > 0 ? `
                    <optgroup label="Otros métodos numéricos">
                        ${numericSecondary.map(method => 
                            `<option value="${method.value}" title="${method.description}">${method.label}</option>`
                        ).join('')}
                    </optgroup>
                ` : ''}
                ${textPrimary.length > 0 || textSecondary.length > 0 ? `
                    <optgroup label="Métodos de texto (usar con precaución)">
                        ${[...textPrimary, ...textSecondary].map(method => 
                            `<option value="${method.value}" title="${method.description}" style="color: #FFA500;">${method.label} ⚠️</option>`
                        ).join('')}
                    </optgroup>
                ` : ''}
            ` : `
                ${textPrimary.length > 0 ? `
                    <optgroup label="Métodos de texto recomendados">
                        ${textPrimary.map(method => 
                            `<option value="${method.value}" title="${method.description}">${method.label}</option>`
                        ).join('')}
                    </optgroup>
                ` : ''}
                ${textSecondary.length > 0 ? `
                    <optgroup label="Otros métodos de texto">
                        ${textSecondary.map(method => 
                            `<option value="${method.value}" title="${method.description}">${method.label}</option>`
                        ).join('')}
                    </optgroup>
                ` : ''}
                ${numericPrimary.length > 0 || numericSecondary.length > 0 ? `
                    <optgroup label="Métodos numéricos (usar con precaución)">
                        ${[...numericPrimary, ...numericSecondary].map(method => 
                            `<option value="${method.value}" title="${method.description}" style="color: #FFA500;">${method.label} ⚠️</option>`
                        ).join('')}
                    </optgroup>
                ` : ''}
            `}
            ${customMethods.length > 0 ? `
                <optgroup label="Funciones personalizadas">
                    ${customMethods.map(method => 
                        `<option value="${method.value}" title="${method.description}">${method.label}</option>`
                    ).join('')}
                </optgroup>
            ` : ''}
        `;
        
        // Restore value if it exists
        if (currentValue) {
            select.value = currentValue;
        }
    }
    
    function onInputColumnChange(column, layerIndex) {
        const escapedColumn = column.replace(/['"\\]/g, '\\$&').replace(/\s/g, '_');
        const inputColSelect = document.getElementById(`input-col-${escapedColumn}-${layerIndex}`);
        
        if (!inputColSelect || !Array.isArray(normalizationConfig[column])) {
            return;
        }
        
        // Store the selected input column in the current layer's config
        if (normalizationConfig[column][layerIndex]) {
            normalizationConfig[column][layerIndex].input_column = inputColSelect.value;
        }
        
        console.log('Updated config with input column:', normalizationConfig[column]);
        
        // Update the input type indicator for this layer based on the selected column
        updateLayerInputTypeFromSelectedColumn(column, layerIndex);
        
        // Update compatibility of this layer's methods
        updateLayerMethodsCompatibility(column, layerIndex);
        
        // Update the checkbox label to show the selected input column
        const inputColumnNameSpan = document.getElementById(`input-column-name-${escapedColumn}-${layerIndex}`);
        if (inputColumnNameSpan) {
            inputColumnNameSpan.textContent = inputColSelect.value;
        }
    }
    
    function updateLayerInputColumnNames(column) {
        const escapedColumn = column.replace(/['"\\]/g, '\\$&').replace(/\s/g, '_');
        
        if (!Array.isArray(normalizationConfig[column])) {
            return;
        }
        
        // For each layer, determine its input column
        for (let i = 0; i < normalizationConfig[column].length; i++) {
            let inputColumnName = column; // Default to original column
            
            if (i === 0) {
                // First layer always uses original column
                inputColumnName = column;
            } else {
                // Later layers use output of previous layer
                const prevLayerIndex = i - 1;
                
                // Check if previous layer has specific output columns
                const prevOutputIndicator = document.getElementById(`output-type-${escapedColumn}-${prevLayerIndex}`);
                if (prevOutputIndicator && prevOutputIndicator.dataset.realColumns) {
                    try {
                        const prevOutputColumns = JSON.parse(prevOutputIndicator.dataset.realColumns);
                        if (prevOutputColumns.length > 0) {
                            // Use the selected input column or first output column
                            inputColumnName = normalizationConfig[column][i].input_column || prevOutputColumns[0];
                        }
                    } catch (e) {
                        // Fallback to expected column name
                        inputColumnName = `${column}_step${prevLayerIndex + 1}`;
                    }
                } else {
                    // Fallback to expected column name
                    inputColumnName = `${column}_step${prevLayerIndex + 1}`;
                }
            }
            
            // Update the checkbox label
            const inputColumnSpan = document.getElementById(`input-column-name-${escapedColumn}-${i}`);
            if (inputColumnSpan) {
                inputColumnSpan.textContent = inputColumnName;
            }
        }
    }
    
    function onConversionChange(column, layerIndex) {
        const escapedColumn = column.replace(/['"\\]/g, '\\$&').replace(/\s/g, '_');
        const convSelect = document.getElementById(`conv-${escapedColumn}-${layerIndex}`);
        
        if (!convSelect || !Array.isArray(normalizationConfig[column])) {
            return;
        }
        
        // Store the conversion in the previous layer's config
        if (layerIndex > 0 && normalizationConfig[column][layerIndex - 1]) {
            if (convSelect.value) {
                normalizationConfig[column][layerIndex - 1].conversion = convSelect.value;
            } else {
                delete normalizationConfig[column][layerIndex - 1].conversion;
            }
            
            // Update the output type indicator of the previous layer to reflect the conversion
            const prevMethod = normalizationConfig[column][layerIndex - 1].method;
            if (prevMethod) {
                updateLayerOutputTypeIndicatorWithConversion(column, layerIndex - 1, prevMethod, convSelect.value);
            }
        }
        
        console.log('Updated config with conversion:', normalizationConfig[column]);
    }
    
    function updateLayerOutputTypeIndicatorWithConversion(column, layerIndex, method, conversion) {
        const escapedColumn = column.replace(/['"\\]/g, '\\$&').replace(/\s/g, '_');
        const outputIndicator = document.getElementById(`output-type-${escapedColumn}-${layerIndex}`);
        
        if (!outputIndicator) return;
        
        if (!method) {
            outputIndicator.style.display = 'none';
            return;
        }
        
        // Get method info
        const info = datasetInfo.normalization_info[column];
        const methodInfo = [...info.primary_methods, ...info.secondary_methods].find(m => m.value === method);
        
        if (methodInfo) {
            let outputType = methodInfo.output_type || 'unknown';
            let outputDType = methodInfo.output_dtype || 'unknown';
            
            // If there's a conversion, override the output dtype
            if (conversion) {
                if (conversion === 'TO_FLOAT64') outputDType = 'float64';
                else if (conversion === 'TO_FLOAT32') outputDType = 'float32';
                else if (conversion === 'TO_INT64') outputDType = 'Int64';
                else if (conversion === 'TO_INT32') outputDType = 'Int32';
                else if (conversion === 'TO_INT16') outputDType = 'Int16';
                else if (conversion === 'TO_STRING') {
                    outputDType = 'object';
                    outputType = 'text';
                } else if (conversion === 'TO_NUMERIC') {
                    outputDType = 'float64';
                    outputType = 'numeric';
                }
            }
            
            outputIndicator.innerHTML = `
                <i class="bi bi-arrow-right" style="opacity: 0.7;"></i>
                Salida: ${outputType === 'numeric' ? 'Numérico' : outputType === 'text' ? 'Texto' : 'Desconocido'}
                ${outputDType !== 'unknown' ? ` (${outputDType})` : ''}
                ${conversion ? ' <i class="bi bi-arrow-down-up" title="Con conversión"></i>' : ''}
            `;
            outputIndicator.style.display = 'inline-block';
            
            // Update color based on type
            if (outputType === 'numeric') {
                outputIndicator.style.background = 'rgba(0, 212, 255, 0.2)';
                outputIndicator.style.borderColor = 'rgba(0, 212, 255, 0.5)';
            } else if (outputType === 'text') {
                outputIndicator.style.background = 'rgba(255, 107, 107, 0.2)';
                outputIndicator.style.borderColor = 'rgba(255, 107, 107, 0.5)';
            }
        } else {
            outputIndicator.style.display = 'none';
        }
    }
    
    async function updateNextLayerInputSelector(column, layerIndex) {
        const escapedColumn = column.replace(/['"\\]/g, '\\$&').replace(/\s/g, '_');
        const method = normalizationConfig[column][layerIndex]?.method;
        
        if (!method || !method.startsWith('CUSTOM_')) return;
        
        // Check if there's a next layer
        const nextLayerIndex = layerIndex + 1;
        const layersContainer = document.getElementById(`layers-${escapedColumn}`);
        if (!layersContainer) return;
        
        const nextLayer = layersContainer.querySelector(`[data-layer-index="${nextLayerIndex}"]`);
        if (!nextLayer) return;
        
        // Get the output columns from this layer
        const outputIndicator = document.getElementById(`output-type-${escapedColumn}-${layerIndex}`);
        if (!outputIndicator || !outputIndicator.dataset.expectedColumns) return;
        
        try {
            // First try to get real column names via preview
            let realColumnNames = null;
            
            // Build config up to this layer
            const previewConfig = {};
            previewConfig[column] = normalizationConfig[column].slice(0, layerIndex + 1).filter(layer => layer && layer.method);
            
            try {
                const response = await fetch(`/api/datasets/${datasetId}/normalization/preview/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        normalization: previewConfig,
                        sample_size: 5  // Just need a small sample to get column names
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Check if we have column info
                    if (data.preview && data.preview[column]) {
                        const colData = data.preview[column];
                        
                        if (colData.new_columns) {
                            realColumnNames = colData.new_columns;
                        } else if (colData.column_types_info) {
                            realColumnNames = colData.column_types_info.map(info => info.name);
                        }
                    }
                }
            } catch (error) {
                console.log('Could not fetch real column names, using expected ones');
            }
            
            // Use real names if available, otherwise fall back to expected
            const outputColumns = realColumnNames || JSON.parse(outputIndicator.dataset.expectedColumns);
            
            // Store real column names for future use
            if (realColumnNames) {
                outputIndicator.dataset.realColumns = JSON.stringify(realColumnNames);
            }
            
            // Check if we need to add/update the input selector
            let inputSelector = nextLayer.querySelector('.input-column-selector');
            
            if (outputColumns && outputColumns.length > 1) {
                if (!inputSelector) {
                    // Create the input selector
                    const selectorHtml = `
                        <div class="input-column-selector" style="margin: 10px 0; padding: 10px; background: rgba(0, 212, 255, 0.05); border: 1px solid rgba(0, 212, 255, 0.3); border-radius: 8px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <i class="bi bi-columns-gap" style="color: var(--primary-color);"></i>
                                <span style="color: rgba(240, 249, 255, 0.8); font-weight: 500;">Columna de entrada:</span>
                                <select class="input-column-select" id="input-col-${escapedColumn}-${nextLayerIndex}" 
                                        onchange="onInputColumnChange('${column.replace(/'/g, "\\'")}', ${nextLayerIndex})"
                                        style="flex: 1; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(0, 212, 255, 0.3); color: var(--light-color); padding: 5px 10px; border-radius: 5px;">
                                    ${outputColumns.map((col, idx) => 
                                        `<option value="${col}" ${idx === 0 ? 'selected' : ''}>${col}</option>`
                                    ).join('')}
                                </select>
                            </div>
                            <div style="margin-top: 5px; font-size: 0.85rem; color: rgba(240, 249, 255, 0.6);">
                                <i class="bi bi-info-circle"></i> La capa anterior genera múltiples columnas. Selecciona sobre cuál aplicar la normalización.
                            </div>
                        </div>
                    `;
                    
                    // Insert at the beginning of the layer
                    nextLayer.insertAdjacentHTML('afterbegin', selectorHtml);
                    
                    // Update config
                    if (!normalizationConfig[column][nextLayerIndex]) {
                        normalizationConfig[column][nextLayerIndex] = {};
                    }
                    normalizationConfig[column][nextLayerIndex].input_column = outputColumns[0];
                } else {
                    // Update existing selector
                    const select = inputSelector.querySelector('select');
                    if (select) {
                        const currentValue = select.value;
                        select.innerHTML = outputColumns.map((col, idx) => 
                            `<option value="${col}" ${col === currentValue ? 'selected' : ''}>${col}</option>`
                        ).join('');
                        
                        // Update config if value changed
                        if (!outputColumns.includes(currentValue) && outputColumns.length > 0) {
                            normalizationConfig[column][nextLayerIndex].input_column = outputColumns[0];
                            select.value = outputColumns[0];
                        }
                    }
                }
            } else if (inputSelector) {
                // Remove the selector if no longer needed
                inputSelector.remove();
                if (normalizationConfig[column][nextLayerIndex]) {
                    delete normalizationConfig[column][nextLayerIndex].input_column;
                }
            }
        } catch (e) {
            console.error('Error updating input selector:', e);
        }
    }

    function renderVariables() {
        console.log('renderVariables called');
        const grid = document.getElementById('variables-grid');
        if (!grid) {
            console.error('variables-grid element not found!');
            return;
        }
        
        console.log('datasetInfo:', datasetInfo);
        console.log('normalization_info:', datasetInfo?.normalization_info);
        
        grid.innerHTML = '';
        
        if (!datasetInfo || !datasetInfo.normalization_info) {
            console.error('No normalization info available');
            grid.innerHTML = '<div class="alert alert-warning">No se encontró información de normalización</div>';
            return;
        }
        
        const entries = Object.entries(datasetInfo.normalization_info);
        console.log(`Found ${entries.length} columns to render`);
        
        for (const [column, info] of entries) {
            console.log(`Creating card for column: ${column}`);
            const card = createVariableCard(column, info);
            grid.appendChild(card);
        }
    }

    function createVariableCard(column, info) {
        const card = document.createElement('div');
        card.className = 'variable-card';
        
        // Escapar el nombre de la columna para uso en IDs y funciones
        const escapedColumn = column.replace(/['"\\]/g, '\\$&').replace(/\s/g, '_');
        
        // Determinar el tipo de badge
        const typeClass = `type-${info.type}`;
        const typeLabel = info.type === 'numeric' ? 'Numérico' : 
                         info.type === 'text' ? 'Texto' : 'Desconocido';
        
        // Crear contenido de estadísticas
        let statsHtml = '';
        if (info.type === 'numeric' && info.stats) {
            statsHtml = `
                <div class="variable-stats">
                    ${info.stats.mean !== null ? `Media: ${info.stats.mean.toFixed(2)}` : ''}
                    ${info.stats.std !== null ? ` | Desv: ${info.stats.std.toFixed(2)}` : ''}<br>
                    ${info.stats.min !== null ? `Min: ${info.stats.min.toFixed(2)}` : ''}
                    ${info.stats.max !== null ? ` | Max: ${info.stats.max.toFixed(2)}` : ''}
                </div>
            `;
        } else if (info.type === 'text' && info.stats) {
            statsHtml = `
                <div class="variable-stats">
                    ${info.stats.unique_count} valores únicos<br>
                    ${info.stats.sample_values ? `Ej: ${info.stats.sample_values.slice(0, 2).join(', ')}...` : ''}
                </div>
            `;
        }
        
        card.innerHTML = `
            <div class="variable-header">
                <span class="variable-name">${column}</span>
                <span class="variable-type ${typeClass}">${typeLabel}</span>
            </div>
            ${statsHtml}
            <div class="normalization-layers" id="layers-${escapedColumn}" data-column="${column}">
                <div class="normalization-layer" data-layer-index="0">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                        <span style="color: var(--primary-color); font-weight: bold;">Capa 1:</span>
                        <span class="compatibility-indicator ${info.type}">
                            Entrada: ${typeLabel}${info.dtype ? ` (${info.dtype})` : ''}
                        </span>
                        <span class="output-type-indicator" id="output-type-${escapedColumn}-0" style="display: none; margin-left: 10px; padding: 2px 8px; background: rgba(147, 51, 234, 0.2); border: 1px solid rgba(147, 51, 234, 0.5); border-radius: 4px; font-size: 0.85rem;">
                            <!-- Output type will be updated when method is selected -->
                        </span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <select class="normalization-select" id="norm-${escapedColumn}-0" 
                                onchange="onNormalizationChange('${column.replace(/'/g, "\\'")}', 0)"
                                style="flex: 1;">
                            <option value="">Sin normalizar</option>
                            <optgroup label="Métodos principales">
                                ${info.primary_methods.map(method => 
                                    `<option value="${method.value}" title="${method.description}">${method.label}</option>`
                                ).join('')}
                            </optgroup>
                            ${info.secondary_methods.length > 0 ? `
                                <optgroup label="Otros métodos">
                                    ${info.secondary_methods.map(method => 
                                        `<option value="${method.value}" title="${method.description}">${method.label}</option>`
                                    ).join('')}
                                </optgroup>
                            ` : ''}
                        </select>
                        <button class="btn btn-sm btn-outline-info preview-layer-btn" 
                                onclick="previewLayer('${column.replace(/'/g, "\\'")}', 0)" 
                                title="Previsualizar esta capa"
                                style="display: none;">
                            <i class="bi bi-eye"></i>
                        </button>
                    </div>
                    <div class="keep-original-container" id="keep-original-${escapedColumn}-0" style="display: none; margin-top: 10px;">
                        <label class="form-check-label" style="display: flex; align-items: center; gap: 8px; color: rgba(240, 249, 255, 0.8);">
                            <input type="checkbox" class="form-check-input keep-original-checkbox" 
                                   id="keep-original-checkbox-${escapedColumn}-0" 
                                   onchange="onKeepOriginalChangeForLayer('${column.replace(/'/g, "\\'")}', 0)"
                                   style="margin: 0;">
                            <span style="font-size: 0.9rem;">Mantener columna de entrada: <strong>${column}</strong></span>
                        </label>
                    </div>
                </div>
            </div>
            <div class="layer-controls" style="display: none;" id="layer-controls-${escapedColumn}" data-column="${column}">
                <button type="button" class="add-layer-btn" onclick="event.preventDefault(); addNormalizationLayer('${column.replace(/'/g, "\\'")}')" title="Añadir capa de normalización">
                    <i class="bi bi-plus-circle"></i> Añadir capa
                </button>
            </div>
            
            <!-- Botón de previsualización general -->
            <button class="preview-btn" onclick="previewNormalization('${column.replace(/'/g, "\\'")}')" 
                    id="preview-btn-${escapedColumn}" style="display: none;">
                <i class="bi bi-eye"></i> Previsualizar transformación completa
            </button>
        `;
        
        return card;
    }

    function onNormalizationChange(column, layerIndex = 0) {
        const escapedColumn = column.replace(/['"\\]/g, '\\$&').replace(/\s/g, '_');
        const select = document.getElementById(`norm-${escapedColumn}-${layerIndex}`);
        const previewBtn = document.getElementById(`preview-btn-${escapedColumn}`);
        const keepOriginalContainer = document.getElementById(`keep-original-${escapedColumn}-${layerIndex}`);  // Per-layer checkbox
        const layerControls = document.getElementById(`layer-controls-${escapedColumn}`);
        
        // Mostrar/ocultar botón de preview de la capa
        const layerPreviewBtn = document.querySelector(`#layers-${escapedColumn} [data-layer-index="${layerIndex}"] .preview-layer-btn`);
        if (layerPreviewBtn) {
            layerPreviewBtn.style.display = select.value ? 'inline-block' : 'none';
        }
        
        // Lista de funciones por defecto
        const defaultFunctions = [
            'min_max', 'MIN_MAX', 'minmax',
            'z_score', 'Z_SCORE', 'standard', 'standardization',
            'lstm_tcn', 'LSTM_TCN',
            'cnn', 'CNN',
            'transformer', 'TRANSFORMER', 'robust', 'robust_scaler',
            'tree', 'TREE', 'none', 'no_normalization',
            'lower', 'LOWER', 'lowercase',
            'strip', 'STRIP',
            'one_hot', 'ONE_HOT', 'onehot', 'label', 'label_encoding'
        ];
        
        if (select.value) {
            // Initialize array if not exists
            if (!Array.isArray(normalizationConfig[column])) {
                normalizationConfig[column] = [];
            }
            
            // Update the specific layer, preserving input_column and keep_original if they exist
            const existingConfig = normalizationConfig[column][layerIndex] || {};
            
            // Get the current checkbox state for this layer
            const checkbox = document.getElementById(`keep-original-checkbox-${escapedColumn}-${layerIndex}`);
            let keepOriginalValue = false;
            
            // If checkbox exists, use its value; otherwise use existing value or default
            if (checkbox) {
                keepOriginalValue = checkbox.checked;
            } else if (existingConfig.hasOwnProperty('keep_original')) {
                keepOriginalValue = existingConfig.keep_original;
            } else {
                // Default: do not keep original (false)
                keepOriginalValue = false;
            }
            
            normalizationConfig[column][layerIndex] = {
                method: select.value,
                keep_original: keepOriginalValue,
                ...(existingConfig.input_column && { input_column: existingConfig.input_column })  // Preserve input_column if it exists
            };
            
            previewBtn.style.display = 'block';
            layerControls.style.display = 'block';
            
            // Mostrar checkbox para todas las funciones
            keepOriginalContainer.style.display = 'block';
            
            // Initialize checkbox state based on config (reuse existing checkbox variable)
            if (checkbox && normalizationConfig[column][layerIndex]) {
                checkbox.checked = normalizationConfig[column][layerIndex].keep_original || false;
            }
            
            // Para cualquier función, usar el valor por defecto (false) si no existe
            if (!normalizationConfig[column][layerIndex].hasOwnProperty('keep_original')) {
                normalizationConfig[column][layerIndex].keep_original = false;
            }
            
            // Update output type indicator
            updateLayerOutputTypeIndicator(column, layerIndex, select.value);
            
            // Also update output type if it's the first layer and a conversion is set
            if (layerIndex === 0 && normalizationConfig[column][0].conversion) {
                updateLayerOutputTypeIndicatorWithConversion(column, 0, select.value, normalizationConfig[column][0].conversion);
            }
            
            // Update input column names for all layers of this column
            updateLayerInputColumnNames(column);
            
            // Update input column selector for next layer if it exists
            updateNextLayerInputSelector(column, layerIndex);
            
            // Update compatibility of subsequent layers
            updateSubsequentLayersCompatibility(column, layerIndex);
        } else {
            // Remove this layer
            if (Array.isArray(normalizationConfig[column])) {
                normalizationConfig[column].splice(layerIndex, 1);
                if (normalizationConfig[column].length === 0) {
                    delete normalizationConfig[column];
                    previewBtn.style.display = 'none';
                    layerControls.style.display = 'none';
                }
            }
            keepOriginalContainer.style.display = 'none';
            
            // Hide output type indicator when no method is selected
            const outputIndicator = document.getElementById(`output-type-${escapedColumn}-${layerIndex}`);
            if (outputIndicator) {
                outputIndicator.style.display = 'none';
            }
        }
        
        updateSelectedCount();
    }
    
    function updateSubsequentLayersCompatibility(column, changedLayerIndex) {
        const escapedColumn = column.replace(/['"\\]/g, '\\$&').replace(/\s/g, '_');
        const layersContainer = document.getElementById(`layers-${escapedColumn}`);
        
        if (!layersContainer) return;
        
        const layers = layersContainer.querySelectorAll('.normalization-layer');
        
        // Update all layers after the changed one
        for (let i = changedLayerIndex + 1; i < layers.length; i++) {
            const layer = layers[i];
            
            // Update input type based on previous layer
            let inputType = 'numeric'; // Default
            
            if (i > 0 && Array.isArray(normalizationConfig[column]) && normalizationConfig[column][i - 1]) {
                const prevMethod = normalizationConfig[column][i - 1].method;
                const info = datasetInfo.normalization_info[column];
                const prevMethodInfo = [...info.primary_methods, ...info.secondary_methods].find(m => m.value === prevMethod);
                if (prevMethodInfo && prevMethodInfo.output_type) {
                    inputType = prevMethodInfo.output_type;
                }
            }
            
            // Update the input indicator for this layer
            const inputIndicator = layer.querySelector('.compatibility-indicator');
            if (inputIndicator) {
                inputIndicator.className = `compatibility-indicator ${inputType}`;
                // Get specific data type
                const prevOutputDType = getOutputDataType(column, i - 1);
                inputIndicator.textContent = `Entrada: ${inputType === 'numeric' ? 'Numérico' : 'Texto'}${prevOutputDType && prevOutputDType !== 'unknown' ? ` (${prevOutputDType})` : ''}`;
            }
            
            // Store the input type in the layer
            layer.dataset.inputType = inputType;
            
            // Check if there's an input column selector and update its type
            if (normalizationConfig[column][i] && normalizationConfig[column][i].input_column) {
                // Update the input type based on the selected column
                updateLayerInputTypeFromSelectedColumn(column, i);
            } else {
                // Update methods compatibility with the new approach
                updateLayerMethodsCompatibility(column, i);
            }
        }
    }

    function onKeepOriginalChangeForLayer(column, layerIndex) {
        const escapedColumn = column.replace(/['"\\]/g, '\\$&').replace(/\s/g, '_');
        const checkbox = document.getElementById(`keep-original-checkbox-${escapedColumn}-${layerIndex}`);
        
        // Update only the specific layer's keep_original value
        if (Array.isArray(normalizationConfig[column]) && normalizationConfig[column][layerIndex]) {
            normalizationConfig[column][layerIndex].keep_original = checkbox.checked;
            console.log(`Updated keep_original for layer ${layerIndex + 1} of column '${column}' to:`, checkbox.checked);
        }
    }
    
    async function previewLayer(column, layerIndex) {
        console.log('previewLayer called:', column, layerIndex);
        const config = normalizationConfig[column];
        console.log('Current config:', config);
        
        if (!config || !Array.isArray(config) || !config[layerIndex]) {
            showNotification('No hay configuración para esta capa', 'warning');
            return;
        }
        
        // Mostrar indicador de carga
        const loadingModal = showLoadingModal(`Generando previsualización de capa ${layerIndex + 1}...`);
        
        try {
            // Prepare config up to this layer
            let normConfig = {};
            // Include all layers up to and including the specified layer
            normConfig[column] = config.slice(0, layerIndex + 1).filter(layer => layer && layer.method);
            
            console.log('Sending normalization config:', normConfig);
            console.log('Config details for layer', layerIndex, ':', normConfig[column][layerIndex]);
            
            const response = await fetch(`/api/datasets/${datasetId}/normalization/preview/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    normalization: normConfig,
                    sample_size: 100,
                    show_steps: true
                })
            });
            
            const data = await response.json();
            console.log('Preview response:', data);
            
            if (!response.ok) {
                console.error('Error response:', data);
                
                if (data.error_type === 'CustomFunctionError') {
                    showPreviewError(data.details || data.message);
                    return;
                }
                
                let errorMessage = 'Error al generar previsualización';
                if (data.error) {
                    errorMessage = data.error;
                }
                
                showNotification(errorMessage, 'error');
                return;
            }
            
            // Use the same preview function as the complete transformation
            showPreview(data, column, layerIndex);
            
        } catch (error) {
            console.error('Error al previsualizar capa:', error);
            showNotification('Error al generar previsualización de la capa', 'error');
        } finally {
            // Cerrar el modal de carga
            if (loadingModal) {
                try {
                    loadingModal.hide();
                } catch (e) {
                    console.error('Error hiding loading modal:', e);
                }
            }
        }
    }
    
    // Función removida - ahora usamos showPreview para ambos casos

    function updateSelectedCount() {
        const count = Object.keys(normalizationConfig).length;
        document.getElementById('selected-count').textContent = 
            `${count} variable${count !== 1 ? 's' : ''} seleccionada${count !== 1 ? 's' : ''}`;
        document.getElementById('normalized-count').textContent = count;
        
        const applyBtn = document.getElementById('apply-normalization');
        applyBtn.disabled = count === 0;
    }
    
    function addNormalizationLayer(column) {
        console.log('Adding normalization layer for column:', column);
        const escapedColumn = column.replace(/['"\\]/g, '\\$&').replace(/\s/g, '_');
        const layersContainer = document.getElementById(`layers-${escapedColumn}`);
        
        if (!layersContainer) {
            console.error('Layers container not found for column:', column);
            return;
        }
        
        const existingLayers = layersContainer.querySelectorAll('.normalization-layer');
        const newLayerIndex = existingLayers.length;
        
        // Get column info for methods
        const info = datasetInfo.normalization_info[column];
        
        // Get all methods and separate by type
        const allMethods = [...info.primary_methods, ...info.secondary_methods];
        
        const numericMethods = allMethods.filter(method => 
            ['MIN_MAX', 'Z_SCORE', 'LSTM_TCN', 'CNN', 'TRANSFORMER', 'TREE'].includes(method.value)
        );
        
        const textMethods = allMethods.filter(method => 
            ['LOWER', 'STRIP', 'ONE_HOT'].includes(method.value)
        );
        
        const customMethods = allMethods.filter(method => 
            method.value.startsWith('CUSTOM_')
        );
        
        // Separate into primary and secondary for each type
        const numericPrimary = numericMethods.filter(m => info.primary_methods.some(pm => pm.value === m.value));
        const numericSecondary = numericMethods.filter(m => info.secondary_methods.some(sm => sm.value === m.value));
        const textPrimary = textMethods.filter(m => info.primary_methods.some(pm => pm.value === m.value));
        const textSecondary = textMethods.filter(m => info.secondary_methods.some(sm => sm.value === m.value));
        const customPrimary = customMethods.filter(m => info.primary_methods.some(pm => pm.value === m.value));
        const customSecondary = customMethods.filter(m => info.secondary_methods.some(sm => sm.value === m.value));
        
        // Create new layer
        const newLayer = document.createElement('div');
        newLayer.className = 'normalization-layer';
        newLayer.setAttribute('data-layer-index', newLayerIndex);
        newLayer.style.marginTop = '10px';
        
        // Get previous layer output type for display
        let previousOutputType = null;
        let previousOutputDType = null;
        let previousOutputColumns = null;
        let inputColumnSelectorHtml = '';
        
        if (newLayerIndex > 0 && Array.isArray(normalizationConfig[column]) && normalizationConfig[column][newLayerIndex - 1]) {
            const prevMethod = normalizationConfig[column][newLayerIndex - 1].method;
            const prevMethodInfo = [...info.primary_methods, ...info.secondary_methods].find(m => m.value === prevMethod);
            if (prevMethodInfo && prevMethodInfo.output_type) {
                previousOutputType = prevMethodInfo.output_type;
                // Get the specific data type using getOutputDataType function
                previousOutputDType = getOutputDataType(column, newLayerIndex - 1);
            }
            
            // Check if previous method generates multiple columns
            if (prevMethod.startsWith('CUSTOM_')) {
                // Get info about the custom function
                const outputIndicator = document.getElementById(`output-type-${escapedColumn}-${newLayerIndex - 1}`);
                if (outputIndicator) {
                    try {
                        // First try to use real columns if available
                        if (outputIndicator.dataset.realColumns) {
                            previousOutputColumns = JSON.parse(outputIndicator.dataset.realColumns);
                        } else if (outputIndicator.dataset.expectedColumns) {
                            previousOutputColumns = JSON.parse(outputIndicator.dataset.expectedColumns);
                        }
                        
                        console.log('Previous layer outputs columns:', previousOutputColumns);
                        
                        // Create column selector for input
                        if (previousOutputColumns && previousOutputColumns.length > 1) {
                            inputColumnSelectorHtml = `
                                <div class="input-column-selector" style="margin: 10px 0; padding: 10px; background: rgba(0, 212, 255, 0.05); border: 1px solid rgba(0, 212, 255, 0.3); border-radius: 8px;">
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <i class="bi bi-columns-gap" style="color: var(--primary-color);"></i>
                                        <span style="color: rgba(240, 249, 255, 0.8); font-weight: 500;">Columna de entrada:</span>
                                        <select class="input-column-select" id="input-col-${escapedColumn}-${newLayerIndex}" 
                                                onchange="onInputColumnChange('${column.replace(/'/g, "\\'")}', ${newLayerIndex})"
                                                style="flex: 1; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(0, 212, 255, 0.3); color: var(--light-color); padding: 5px 10px; border-radius: 5px;">
                                            ${previousOutputColumns.map((col, idx) => 
                                                `<option value="${col}" ${idx === 0 ? 'selected' : ''}>${col}</option>`
                                            ).join('')}
                                        </select>
                                    </div>
                                    <div style="margin-top: 5px; font-size: 0.85rem; color: rgba(240, 249, 255, 0.6);">
                                        <i class="bi bi-info-circle"></i> La capa anterior genera múltiples columnas. Selecciona sobre cuál aplicar la normalización.
                                    </div>
                                </div>
                            `;
                            
                            // Initialize the config with the selected input column
                            if (!normalizationConfig[column][newLayerIndex]) {
                                normalizationConfig[column][newLayerIndex] = {};
                            }
                            normalizationConfig[column][newLayerIndex].input_column = previousOutputColumns[0];
                            
                            // Try to get real column names if not already available
                            if (!outputIndicator.dataset.realColumns) {
                                // Trigger async update to get real names
                                setTimeout(() => updateNextLayerInputSelector(column, newLayerIndex - 1), 100);
                            }
                            
                            // Also trigger update of input type based on selected column
                            setTimeout(() => updateLayerInputTypeFromSelectedColumn(column, newLayerIndex), 200);
                        }
                    } catch (e) {
                        console.error('Error parsing columns:', e);
                    }
                }
            }
        }
        
        // Add conversion dropdown before this layer if not the first layer
        let conversionHtml = '';
        if (newLayerIndex > 0 && previousOutputType) {
            // Check if we need automatic conversion (e.g., after ONE_HOT)
            let autoConversion = '';
            if (normalizationConfig[column] && normalizationConfig[column][newLayerIndex - 1]) {
                const prevMethod = normalizationConfig[column][newLayerIndex - 1].method;
                // If previous method was ONE_HOT, suggest float conversion
                if (prevMethod === 'ONE_HOT') {
                    autoConversion = 'TO_FLOAT64';
                }
            }
            
            conversionHtml = `
                <div class="conversion-container" style="margin: 15px 0; padding: 15px; background: rgba(147, 51, 234, 0.1); border: 1px solid rgba(147, 51, 234, 0.3); border-radius: 10px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <i class="bi bi-arrow-down-square" style="color: var(--primary-color);"></i>
                        <span style="color: rgba(240, 249, 255, 0.8); font-weight: 500;">Conversión de tipo:</span>
                        <select class="conversion-select" id="conv-${escapedColumn}-${newLayerIndex}" 
                                onchange="onConversionChange('${column.replace(/'/g, "\\'")}', ${newLayerIndex})"
                                style="flex: 1; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(0, 212, 255, 0.3); color: var(--light-color); padding: 5px 10px; border-radius: 5px;">
                            <option value="">Sin conversión</option>
                            ${getConversionOptions(previousOutputType).map(conv => 
                                `<option value="${conv.value}" title="${conv.description}" ${conv.value === autoConversion ? 'selected' : ''}>${conv.label}</option>`
                            ).join('')}
                        </select>
                    </div>
                    ${autoConversion ? `
                        <div style="margin-top: 10px; font-size: 0.85rem; color: rgba(255, 193, 7, 0.8);">
                            <i class="bi bi-info-circle"></i> Conversión sugerida después de ONE_HOT para compatibilidad con métodos numéricos
                        </div>
                    ` : ''}
                </div>
            `;
            
            // If auto-conversion was set, also update the config
            if (autoConversion && normalizationConfig[column][newLayerIndex - 1]) {
                normalizationConfig[column][newLayerIndex - 1].conversion = autoConversion;
            }
        }
        
        // Set initial input type based on previous layer
        let initialInputType = previousOutputType || 'numeric';
        
        newLayer.innerHTML = inputColumnSelectorHtml + conversionHtml + `
            <div style="display: flex; align-items: center; gap: 10px;">
                <span style="color: var(--primary-color); font-weight: bold;">Capa ${newLayerIndex + 1}:</span>
                ${previousOutputType ? `
                    <span class="compatibility-indicator ${previousOutputType}">
                        Entrada: ${previousOutputType === 'numeric' ? 'Numérico' : 'Texto'}${previousOutputDType && previousOutputDType !== 'unknown' ? ` (${previousOutputDType})` : ''}
                    </span>
                ` : ''}
                <span class="output-type-indicator" id="output-type-${escapedColumn}-${newLayerIndex}" style="display: none; margin-left: 10px; padding: 2px 8px; background: rgba(147, 51, 234, 0.2); border: 1px solid rgba(147, 51, 234, 0.5); border-radius: 4px; font-size: 0.85rem;">
                    <!-- Output type will be updated when method is selected -->
                </span>
                <button type="button" class="remove-layer-btn" data-column="${column}" data-layer-index="${newLayerIndex}"
                        style="background: transparent; border: none; color: #ff4444; cursor: pointer; padding: 5px; position: relative; z-index: 100; width: 30px; height: 30px;">
                    <i class="bi bi-x-circle"></i>
                </button>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <select class="normalization-select" id="norm-${escapedColumn}-${newLayerIndex}" 
                        onchange="onNormalizationChange('${column.replace(/'/g, "\\'")}', ${newLayerIndex})"
                        style="flex: 1;">
                    <option value="">Sin normalizar</option>
                    ${initialInputType === 'numeric' ? `
                        ${numericPrimary.length > 0 ? `
                            <optgroup label="Métodos numéricos recomendados">
                                ${numericPrimary.map(method => 
                                    `<option value="${method.value}" title="${method.description}">${method.label}</option>`
                                ).join('')}
                            </optgroup>
                        ` : ''}
                        ${numericSecondary.length > 0 ? `
                            <optgroup label="Otros métodos numéricos">
                                ${numericSecondary.map(method => 
                                    `<option value="${method.value}" title="${method.description}">${method.label}</option>`
                                ).join('')}
                            </optgroup>
                        ` : ''}
                        ${textPrimary.length > 0 || textSecondary.length > 0 ? `
                            <optgroup label="Métodos de texto (usar con precaución)">
                                ${[...textPrimary, ...textSecondary].map(method => 
                                    `<option value="${method.value}" title="${method.description}" style="color: #FFA500;">${method.label} ⚠️</option>`
                                ).join('')}
                            </optgroup>
                        ` : ''}
                    ` : `
                        ${textPrimary.length > 0 ? `
                            <optgroup label="Métodos de texto recomendados">
                                ${textPrimary.map(method => 
                                    `<option value="${method.value}" title="${method.description}">${method.label}</option>`
                                ).join('')}
                            </optgroup>
                        ` : ''}
                        ${textSecondary.length > 0 ? `
                            <optgroup label="Otros métodos de texto">
                                ${textSecondary.map(method => 
                                    `<option value="${method.value}" title="${method.description}">${method.label}</option>`
                                ).join('')}
                            </optgroup>
                        ` : ''}
                        ${numericPrimary.length > 0 || numericSecondary.length > 0 ? `
                            <optgroup label="Métodos numéricos (usar con precaución)">
                                ${[...numericPrimary, ...numericSecondary].map(method => 
                                    `<option value="${method.value}" title="${method.description}" style="color: #FFA500;">${method.label} ⚠️</option>`
                                ).join('')}
                            </optgroup>
                        ` : ''}
                    `}
                    ${customMethods.length > 0 ? `
                        <optgroup label="Funciones personalizadas">
                            ${customMethods.map(method => 
                                `<option value="${method.value}" title="${method.description}">${method.label}</option>`
                            ).join('')}
                        </optgroup>
                    ` : ''}
                </select>
                <button class="btn btn-sm btn-outline-info preview-layer-btn" 
                        onclick="previewLayer('${column.replace(/'/g, "\\'")}', ${newLayerIndex})" 
                        title="Previsualizar esta capa"
                        style="display: none;">
                    <i class="bi bi-eye"></i>
                </button>
            </div>
            <div class="keep-original-container" id="keep-original-${escapedColumn}-${newLayerIndex}" style="display: none; margin-top: 10px;">
                <label class="form-check-label" style="display: flex; align-items: center; gap: 8px; color: rgba(240, 249, 255, 0.8);">
                    <input type="checkbox" class="form-check-input keep-original-checkbox" 
                           id="keep-original-checkbox-${escapedColumn}-${newLayerIndex}" 
                           onchange="onKeepOriginalChangeForLayer('${column.replace(/'/g, "\\'")}', ${newLayerIndex})"
                           style="margin: 0;">
                    <span style="font-size: 0.9rem;">Mantener columna de entrada: <strong id="input-column-name-${escapedColumn}-${newLayerIndex}">${newLayerIndex === 0 ? column : (previousOutputColumns && previousOutputColumns.length === 1 ? previousOutputColumns[0] : (previousOutputColumns && previousOutputColumns.length > 1 ? previousOutputColumns[0] : column + '_step' + (newLayerIndex)))}</strong></span>
                </label>
            </div>
        `;
        
        // Store the input type in the layer
        newLayer.dataset.inputType = initialInputType;
        
        layersContainer.appendChild(newLayer);
        
        // Add event listener using data attributes
        const removeBtn = newLayer.querySelector('.remove-layer-btn');
        if (removeBtn) {
            removeBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                const col = this.getAttribute('data-column');
                const idx = parseInt(this.getAttribute('data-layer-index'));
                console.log('Remove button clicked:', col, idx);
                removeNormalizationLayer(col, idx);
            });
        }
    }
    
    function removeNormalizationLayer(column, layerIndex) {
        console.log('Removing layer:', column, layerIndex);
        
        // Don't allow removing the first layer
        if (layerIndex === 0) {
            showNotification('No se puede eliminar la primera capa', 'warning');
            return;
        }
        
        const escapedColumn = column.replace(/['"\\]/g, '\\$&').replace(/\s/g, '_');
        const layersContainer = document.getElementById(`layers-${escapedColumn}`);
        
        if (!layersContainer) {
            console.error('Layers container not found for column:', column);
            return;
        }
        
        const layerToRemove = layersContainer.querySelector(`[data-layer-index="${layerIndex}"]`);
        
        if (layerToRemove) {
            layerToRemove.remove();
            console.log('Layer removed successfully');
            
            // Remove from config
            if (Array.isArray(normalizationConfig[column])) {
                normalizationConfig[column].splice(layerIndex, 1);
                
                // Reindex remaining layers
                const remainingLayers = layersContainer.querySelectorAll('.normalization-layer');
                remainingLayers.forEach((layer, index) => {
                    layer.setAttribute('data-layer-index', index);
                    // Update IDs and event handlers
                    const select = layer.querySelector('.normalization-select');
                    const keepContainer = layer.querySelector('.keep-original-container');
                    const keepCheckbox = layer.querySelector('.keep-original-checkbox');
                    const layerLabel = layer.querySelector('span');
                    const removeBtn = layer.querySelector('.remove-layer-btn');
                    
                    if (select) {
                        select.id = `norm-${escapedColumn}-${index}`;
                        select.setAttribute('onchange', `onNormalizationChange('${column.replace(/'/g, "\\'")}', ${index})`);
                    }
                    if (keepContainer) {
                        keepContainer.id = `keep-original-${escapedColumn}-${index}`;
                    }
                    if (keepCheckbox) {
                        keepCheckbox.id = `keep-original-checkbox-${escapedColumn}-${index}`;
                        keepCheckbox.setAttribute('onchange', `onKeepOriginalChangeForLayer('${column.replace(/'/g, "\\'")}', ${index})`);
                    }
                    if (layerLabel) {
                        layerLabel.textContent = `Capa ${index + 1}:`;
                    }
                    if (removeBtn) {
                        if (index > 0) {  // Show remove button for all layers except first
                            removeBtn.style.display = 'inline-flex';
                            removeBtn.setAttribute('onclick', `event.stopPropagation(); removeNormalizationLayer('${column.replace(/'/g, "\\'")}', ${index})`);
                        } else {
                            removeBtn.style.display = 'none';  // Hide remove button for first layer
                        }
                    }
                });
                
                if (normalizationConfig[column].length === 0) {
                    delete normalizationConfig[column];
                    document.getElementById(`preview-btn-${escapedColumn}`).style.display = 'none';
                    document.getElementById(`layer-controls-${escapedColumn}`).style.display = 'none';
                }
            }
        }
        
        updateSelectedCount();
    }

    async function previewNormalization(column) {
        const config = normalizationConfig[column];
        if (!config) return;
        
        // Mostrar indicador de carga
        const loadingModal = showLoadingModal('Generando previsualización...');
        
        try {
            // Prepare the config - handle both single and array formats
            let normConfig = {};
            if (Array.isArray(config)) {
                // For chained normalization, send as array
                normConfig[column] = config.filter(layer => layer && layer.method);
            } else {
                // Legacy single normalization
                normConfig[column] = config;
            }
            
            const response = await fetch(`/api/datasets/${datasetId}/normalization/preview/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    normalization: normConfig,
                    sample_size: 100,
                    show_steps: true  // Request transformation steps
                })
            });
            
            const data = await response.json();
            
            if (!response.ok) {
                console.error('Error response:', data);
                
                // Si es un error de función personalizada, mostrar en formato especial
                if (data.error_type === 'CustomFunctionError') {
                    showPreviewError(data.details || data.message);
                    return;
                }
                
                let errorMessage = 'Error al generar previsualización';
                
                if (data.error) {
                    errorMessage = data.error;
                    if (data.traceback) {
                        console.error('Traceback:', data.traceback);
                    }
                    if (data.debug_info) {
                        console.error('Debug info:', data.debug_info);
                    }
                }
                
                showNotification(errorMessage, 'error');
                return;
            }
            
            showPreview(data);
            
        } catch (error) {
            // Solo mostrar error de conexión si es realmente un problema de red
            if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
                console.error('Error de conexión:', error);
                showNotification('Error de conexión al generar previsualización', 'error');
            } else if (error.name === 'NetworkError') {
                console.error('Error de red:', error);
                showNotification('Error de conexión al generar previsualización', 'error');
            }
            // Para otros errores, solo registrar en consola sin mostrar notificación
            else {
                console.error('Error procesando respuesta:', error);
            }
        } finally {
            // Cerrar el modal de carga
            if (loadingModal) {
                loadingModal.hide();
            }
        }
    }

    function showPreview(response, specificColumn = null, layerIndex = null) {
        const modal = document.getElementById('preview-modal');
        const body = document.getElementById('preview-body');
        const title = document.getElementById('preview-title');
        
        console.log('showPreview called with:', { response, specificColumn, layerIndex });
        
        // Check for errors first
        if (response.error || response.error_type) {
            let errorHtml = `
                <div style="text-align: center; padding: 40px;">
                    <i class="bi bi-exclamation-triangle" style="font-size: 3rem; color: #ff6b6b;"></i>
                    <h4 style="margin-top: 20px; color: #ff6b6b;">Error en la previsualización</h4>
                    <div style="color: rgba(240, 249, 255, 0.7); margin-top: 20px; text-align: left; background: rgba(255, 107, 107, 0.1); padding: 20px; border-radius: 10px; border: 1px solid rgba(255, 107, 107, 0.3);">
                        ${response.error || response.message || 'Error desconocido'}
                    </div>
                    ${response.details ? `
                        <details style="margin-top: 20px; text-align: left;">
                            <summary style="cursor: pointer; color: var(--primary-color);">Ver detalles técnicos</summary>
                            <pre style="margin-top: 10px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; overflow-x: auto; font-size: 0.85rem; color: #ff6b6b;">
${response.details}
                            </pre>
                        </details>
                    ` : ''}
                    <button class="btn btn-secondary" onclick="closePreview()" style="margin-top: 20px;">
                        Cerrar
                    </button>
                </div>
            `;
            body.innerHTML = errorHtml;
            modal.style.display = 'block';
            return;
        }
        
        // Extraer la columna del preview
        const columns = Object.keys(response.preview || {});
        if (columns.length === 0) {
            // Si no hay preview pero hay transformation_steps, intentar mostrar eso
            if (response.transformation_steps) {
                const stepColumns = Object.keys(response.transformation_steps);
                if (stepColumns.length === 0) {
                    showNotification('No se recibieron datos de previsualización', 'error');
                    return;
                }
                // Use the first column from transformation_steps
                specificColumn = stepColumns[0];
            } else {
                showNotification('No se recibieron datos de previsualización', 'error');
                return;
            }
        }
        
        const column = specificColumn || columns[0];
        const preview = response.preview ? response.preview[column] : null;
        
        // Adjust title based on whether it's a layer preview or complete preview
        if (layerIndex !== null) {
            title.textContent = `Previsualización - ${column} - Capa ${layerIndex + 1}`;
        } else {
            title.textContent = `Previsualización completa: ${column}`;
        }
        
        let bodyHtml = '';
        
        // Show warnings if any
        if (response.warnings && response.warnings.length > 0) {
            bodyHtml += `
                <div class="alert alert-warning" style="background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.5); border-radius: 10px; padding: 15px; margin-bottom: 20px;">
                    <h5 style="color: #ffd93d; margin-bottom: 10px;"><i class="bi bi-exclamation-triangle"></i> Advertencias de conversión de tipo</h5>
                    <ul style="margin-bottom: 0; list-style-type: none; padding-left: 0;">
                        ${response.warnings.map(warning => `<li style="margin-bottom: 5px;"><i class="bi bi-info-circle"></i> ${warning.warning}</li>`).join('')}
                    </ul>
                </div>
            `;
        }
        
        // Get initial and final statistics
        const initialType = datasetInfo.normalization_info[column].type;
        const initialStats = datasetInfo.normalization_info[column].stats;
        
        // Show summary card at the top
        bodyHtml += `
            <div style="background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(147, 51, 234, 0.1)); border: 2px solid var(--primary-color); border-radius: 15px; padding: 20px; margin-bottom: 30px;">
                <h4 style="color: var(--primary-color); margin-bottom: 20px;">
                    <i class="bi bi-diagram-3"></i> ${layerIndex !== null ? `Resumen hasta la capa ${layerIndex + 1}` : 'Resumen de la transformación completa'}
                </h4>
                
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 30px; align-items: center;">
                    <!-- Initial state -->
                    <div style="text-align: center;">
                        <h5 style="color: rgba(240, 249, 255, 0.8); margin-bottom: 10px;">Estado inicial</h5>
                        <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px;">
                            <div class="compatibility-indicator ${initialType}" style="font-size: 1.2rem; margin-bottom: 10px;">
                                ${initialType === 'numeric' ? 'Numérico' : 'Texto'}
                            </div>
                            ${initialStats ? `
                                <div style="font-size: 0.9rem; color: rgba(240, 249, 255, 0.6);">
                                    ${initialType === 'numeric' ? `
                                        Media: ${initialStats.mean ? initialStats.mean.toFixed(2) : 'N/A'}<br>
                                        Rango: [${initialStats.min ? initialStats.min.toFixed(2) : 'N/A'}, ${initialStats.max ? initialStats.max.toFixed(2) : 'N/A'}]
                                    ` : `
                                        ${initialStats.unique_count} valores únicos
                                    `}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                    
                    <!-- Arrow -->
                    <div style="font-size: 3rem; color: var(--primary-color);">
                        <i class="bi bi-arrow-right"></i>
                    </div>
                    
                    <!-- Final state -->
                    <div style="text-align: center;">
                        <h5 style="color: rgba(240, 249, 255, 0.8); margin-bottom: 10px;">${layerIndex !== null ? 'Estado después de esta capa' : 'Estado final'}</h5>
                        <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px;">
                            ${response.transformation_steps && response.transformation_steps[column] ? (() => {
                                // For layer preview, use the specified layer as the "last" step
                                const effectiveLastIndex = layerIndex !== null ? layerIndex : response.transformation_steps[column].length - 1;
                                const lastStep = response.transformation_steps[column][effectiveLastIndex];
                                if (!lastStep) {
                                    return '<div style="color: #ff6b6b;">No se encontró información para esta capa</div>';
                                }
                                const lastMethodInfo = [...datasetInfo.normalization_info[column].primary_methods, 
                                                        ...datasetInfo.normalization_info[column].secondary_methods]
                                                        .find(m => m.value === lastStep.method);
                                const outputType = lastMethodInfo ? lastMethodInfo.output_type : 'unknown';
                                
                                return `
                                    <div class="compatibility-indicator ${outputType}" style="font-size: 1.2rem; margin-bottom: 10px;">
                                        ${outputType === 'numeric' ? 'Numérico' : outputType === 'text' ? 'Texto' : 'Desconocido'}
                                    </div>
                                    ${response.preview[column] && response.preview[column].normalized && response.preview[column].normalized.stats ? `
                                        <div style="font-size: 0.9rem; color: rgba(240, 249, 255, 0.6);">
                                            ${outputType === 'numeric' ? `
                                                Media: ${response.preview[column].normalized.stats.mean ? response.preview[column].normalized.stats.mean.toFixed(2) : 'N/A'}<br>
                                                Rango: [${response.preview[column].normalized.stats.min ? response.preview[column].normalized.stats.min.toFixed(2) : 'N/A'}, 
                                                        ${response.preview[column].normalized.stats.max ? response.preview[column].normalized.stats.max.toFixed(2) : 'N/A'}]
                                            ` : `
                                                Valores transformados
                                            `}
                                        </div>
                                    ` : ''}
                                `;
                            })() : ''}
                        </div>
                    </div>
                </div>
                
                <!-- Chain summary -->
                ${response.transformation_steps && response.transformation_steps[column] ? `
                    <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(0, 212, 255, 0.3);">
                        <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap; justify-content: center;">
                            ${(layerIndex !== null ? response.transformation_steps[column].slice(0, layerIndex + 1) : response.transformation_steps[column]).map((step, idx) => {
                                const methodInfo = [...datasetInfo.normalization_info[column].primary_methods, 
                                                  ...datasetInfo.normalization_info[column].secondary_methods]
                                                  .find(m => m.value === step.method);
                                return `
                                    ${idx > 0 ? '<i class="bi bi-arrow-right" style="color: rgba(0, 212, 255, 0.5);"></i>' : ''}
                                    <div style="background: rgba(0, 0, 0, 0.3); padding: 5px 15px; border-radius: 20px;">
                                        <span style="color: var(--light-color);">${methodInfo ? methodInfo.label : step.method}</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                ` : ''}
            </div>
        `;
        
        // Show transformation steps if available
        if (response.transformation_steps && response.transformation_steps[column]) {
            const steps = response.transformation_steps[column];
            
            // For layer preview, only show the specific layer transformation
            const stepsToShow = layerIndex !== null ? 
                (steps[layerIndex] ? [steps[layerIndex]] : []) : 
                steps;
            
            if (stepsToShow.length === 0) {
                bodyHtml += `
                    <div style="text-align: center; padding: 40px; background: rgba(255, 107, 107, 0.1); border-radius: 10px; margin-top: 20px;">
                        <i class="bi bi-exclamation-circle" style="font-size: 2rem; color: #ff6b6b;"></i>
                        <h5 style="color: #ff6b6b; margin-top: 10px;">No se encontraron datos para la capa ${layerIndex + 1}</h5>
                        <p style="color: rgba(240, 249, 255, 0.7);">Verifica que la capa tenga un método de normalización seleccionado.</p>
                    </div>
                `;
            } else {
                bodyHtml += `
                    <div class="transformation-steps">
                        <h4><i class="bi bi-layers"></i> ${layerIndex !== null ? `Transformación de la capa ${layerIndex + 1}` : 'Detalle de cada transformación'}</h4>
                        <div class="steps-container">
                `;
                
                stepsToShow.forEach((step, index) => {
                // Get method display name
                const methodInfo = [...datasetInfo.normalization_info[column].primary_methods, 
                                  ...datasetInfo.normalization_info[column].secondary_methods]
                                  .find(m => m.value === step.method);
                const methodLabel = methodInfo ? methodInfo.label : step.method;
                
                bodyHtml += `
                    <div class="transformation-step">
                        <div class="step-header">
                            <div class="step-title">
                                <i class="bi bi-stack"></i> Capa ${step.step}
                            </div>
                            <div class="step-method">
                                ${methodLabel}
                            </div>
                        </div>
                        
                        ${step.conversion ? `
                            <div style="margin: 10px 0; padding: 10px; background: rgba(147, 51, 234, 0.1); border: 1px solid rgba(147, 51, 234, 0.3); border-radius: 8px;">
                                <i class="bi bi-arrow-down-square"></i> 
                                <span style="color: rgba(240, 249, 255, 0.8);">Conversión aplicada: </span>
                                <strong>${getConversionLabel(step.conversion)}</strong>
                            </div>
                        ` : ''}
                        
                        <div class="preview-comparison">
                            <div class="preview-column">
                                <h6><i class="bi bi-box-arrow-in-right"></i> Entrada</h6>
                                <div class="preview-values">
                                    ${step.before.slice(0, 10).map(val => 
                                        `<div class="preview-value">${val !== null && val !== undefined ? val : '<span style="color: #888;">null</span>'}</div>`
                                    ).join('')}
                                    ${step.before.length > 10 ? `<div style="text-align: center; color: #888; margin-top: 5px;">... y ${step.before.length - 10} más</div>` : ''}
                                </div>
                            </div>
                            
                            <div class="preview-arrow">
                                <i class="bi bi-arrow-right"></i>
                            </div>
                            
                            <div class="preview-column">
                                <h6><i class="bi bi-box-arrow-right"></i> Salida</h6>
                                <div class="preview-values">
                                    ${step.after.slice(0, 10).map(val => 
                                        `<div class="preview-value">${val !== null && val !== undefined ? 
                                            (typeof val === 'number' ? val.toFixed(4) : val) : 
                                            '<span style="color: #888;">null</span>'}</div>`
                                    ).join('')}
                                    ${step.after.length > 10 ? `<div style="text-align: center; color: #888; margin-top: 5px;">... y ${step.after.length - 10} más</div>` : ''}
                                </div>
                            </div>
                        </div>
                        
                        <div class="step-info">
                            ${step.keep_original ? 
                                `<div style="color: rgba(0, 212, 255, 0.8);">
                                    <i class="bi bi-check-circle"></i> Columna original mantenida
                                </div>` : 
                                `<div style="color: rgba(255, 200, 100, 0.8);">
                                    <i class="bi bi-x-circle"></i> Columna original reemplazada
                                </div>`
                            }
                            ${step.column_name && step.column_name !== column ? 
                                `<div style="color: rgba(0, 255, 150, 0.8); margin-top: 5px;">
                                    <i class="bi bi-plus-circle"></i> Nueva columna creada: <strong>${step.column_name}</strong>
                                </div>` : ''
                            }
                            ${methodInfo && methodInfo.output_type ? 
                                `<div style="color: rgba(240, 249, 255, 0.6); margin-top: 5px;">
                                    <i class="bi bi-tag"></i> Tipo de salida: <span class="compatibility-indicator ${methodInfo.output_type}">
                                        ${methodInfo.output_type === 'numeric' ? 'Numérico' : 'Texto'}
                                    </span>
                                </div>` : ''
                            }
                        </div>
                    </div>
                `;
            });
            
            bodyHtml += `
                    </div>
                </div>
                
                <!-- Resumen de la cadena de transformación -->
                ${layerIndex === null ? `
                <div style="margin-top: 20px; padding: 15px; background: rgba(0, 212, 255, 0.1); border-radius: 8px; border: 1px solid rgba(0, 212, 255, 0.3);">
                    <h5 style="color: var(--primary-color); margin-bottom: 10px;">
                        <i class="bi bi-diagram-3"></i> Resumen de la cadena completa
                    </h5>
                    <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                        ${steps.map((step, idx) => {
                            const methodInfo = [...datasetInfo.normalization_info[column].primary_methods, 
                                              ...datasetInfo.normalization_info[column].secondary_methods]
                                              .find(m => m.value === step.method);
                            let inputType = 'unknown';
                            if (idx === 0) {
                                inputType = datasetInfo.normalization_info[column].type;
                            } else if (steps[idx-1]) {
                                const prevMethodInfo = [...datasetInfo.normalization_info[column].primary_methods, 
                                                       ...datasetInfo.normalization_info[column].secondary_methods]
                                                       .find(m => m.value === steps[idx-1].method);
                                inputType = prevMethodInfo ? prevMethodInfo.output_type : 'unknown';
                            }
                            const outputType = methodInfo ? methodInfo.output_type : 'unknown';
                            
                            return `
                                ${idx > 0 ? '<i class="bi bi-arrow-right" style="color: rgba(0, 212, 255, 0.5);"></i>' : ''}
                                <div style="background: rgba(0, 0, 0, 0.3); padding: 5px 15px; border-radius: 20px; display: inline-flex; align-items: center; gap: 8px;">
                                    <span class="compatibility-indicator ${inputType}" style="font-size: 0.7rem;">
                                        ${inputType === 'numeric' ? '123' : 'ABC'}
                                    </span>
                                    <span style="color: var(--light-color);">${methodInfo ? methodInfo.label : step.method}</span>
                                    <span class="compatibility-indicator ${outputType}" style="font-size: 0.7rem;">
                                        ${outputType === 'numeric' ? '123' : 'ABC'}
                                    </span>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
                ` : ''}
                
                <hr style="border-color: rgba(0, 212, 255, 0.3); margin: 20px 0;">
            `;
            }
        } else {
            // No transformation steps available
            if (layerIndex !== null) {
                bodyHtml += `
                    <div style="text-align: center; padding: 40px; background: rgba(255, 107, 107, 0.1); border-radius: 10px; margin-top: 20px;">
                        <i class="bi bi-exclamation-triangle" style="font-size: 3rem; color: #ff6b6b;"></i>
                        <h4 style="color: #ff6b6b; margin-top: 20px;">No se encontraron pasos de transformación</h4>
                        <p style="color: rgba(240, 249, 255, 0.7); margin-top: 10px;">
                            No se pudo obtener la información de transformación para la capa ${layerIndex + 1}.
                            <br>Asegúrate de que la capa tenga un método de normalización seleccionado.
                        </p>
                    </div>
                `;
            }
        }
        
        if (preview && preview.new_columns) {
            // Multiple columns output (including one-hot encoding)
            
            // Check if there are custom function errors
            if (preview.custom_function_errors) {
                bodyHtml += `
                    <div class="alert alert-danger" style="background: rgba(255, 107, 107, 0.1); border: 1px solid rgba(255, 107, 107, 0.5); color: var(--light-color);">
                        <h5><i class="bi bi-exclamation-triangle"></i> Errores en función personalizada: ${preview.custom_function_errors.function_name}</h5>
                        <p>Se encontraron ${preview.custom_function_errors.total_errors} errores al aplicar la función.</p>
                        
                        ${Object.entries(preview.custom_function_errors.error_summary).map(([error_msg, error_info]) => `
                            <div style="margin-top: 15px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 5px;">
                                <strong>Error:</strong> ${error_msg}<br>
                                <strong>Ocurrencias:</strong> ${error_info.count} veces<br>
                                <strong>Valores de ejemplo que causaron el error:</strong>
                                <ul style="margin: 5px 0;">
                                    ${error_info.example_values.map(val => `<li><code>${val}</code></li>`).join('')}
                                </ul>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            bodyHtml += `
                <div class="alert alert-info">
                    <i class="bi bi-info-circle"></i> Esta función generará ${preview.new_columns.length} nueva${preview.new_columns.length > 1 ? 's' : ''} columna${preview.new_columns.length > 1 ? 's' : ''}
                    ${preview.remove_original ? '<br><i class="bi bi-trash"></i> La columna original será eliminada' : '<br><i class="bi bi-arrow-right"></i> La columna original se mantendrá'}
                </div>
            `;
            
            // Show column types information if available
            if (preview.column_types_info && preview.column_types_info.length > 0) {
                bodyHtml += `
                    <h4>Nuevas columnas y sus tipos:</h4>
                    <table class="table" style="background: rgba(0, 0, 0, 0.2);">
                        <thead>
                            <tr>
                                <th>Nombre de columna</th>
                                <th>Tipo detectado</th>
                                <th>Tipo de datos específico</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${preview.column_types_info.map(col_info => `
                                <tr>
                                    <td><strong>${col_info.name}</strong></td>
                                    <td>
                                        <span class="compatibility-indicator ${col_info.type}">
                                            ${col_info.type === 'numeric' ? 'Numérico' : 'Texto'}
                                        </span>
                                    </td>
                                    <td><code>${col_info.dtype}</code></td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            } else {
                bodyHtml += `
                    <h4>Nuevas columnas:</h4>
                    <ul>
                        ${preview.new_columns.map(col => `<li><strong>${col}</strong></li>`).join('')}
                    </ul>
                `;
            }
            
            // Check if all values are None/null (indicating complete failure)
            let hasAnyValidData = false;
            for (const newCol of preview.new_columns) {
                if (preview[newCol] && preview[newCol].sample) {
                    const validValues = preview[newCol].sample.filter(val => val !== null && val !== undefined);
                    if (validValues.length > 0) {
                        hasAnyValidData = true;
                        break;
                    }
                }
            }
            
            if (!hasAnyValidData && preview.custom_function_errors) {
                bodyHtml += `
                    <div class="alert alert-warning" style="background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.5); color: var(--light-color); margin-top: 20px;">
                        <h5><i class="bi bi-exclamation-circle"></i> Operación fallida completamente</h5>
                        <p>La función personalizada no pudo procesar ningún valor correctamente. Todos los valores resultantes son nulos.</p>
                        <p>Por favor, revisa los errores anteriores y ajusta tu función.</p>
                    </div>
                `;
            }
            
            // Show preview for each new column
            for (const newCol of preview.new_columns) {
                if (preview[newCol]) {
                    const colData = preview[newCol];
                    
                    // Count non-null values
                    const validValues = (colData.sample || []).filter(val => val !== null && val !== undefined);
                    const nullCount = (colData.sample || []).length - validValues.length;
                    
                    bodyHtml += `
                        <div style="margin-top: 20px; border-top: 1px solid rgba(0, 212, 255, 0.2); padding-top: 20px;">
                            <h5 style="color: var(--primary-color);">
                                <i class="bi bi-columns-gap"></i> ${newCol}
                                ${colData.detected_type && colData.detected_dtype ? `
                                    <span style="font-size: 0.8rem; font-weight: normal; margin-left: 10px;">
                                        <span class="compatibility-indicator ${colData.detected_type}" style="padding: 4px 12px;">
                                            ${colData.detected_type === 'numeric' ? 'Numérico' : 'Texto'} (${colData.detected_dtype})
                                        </span>
                                    </span>
                                ` : ''}
                                ${nullCount > 0 ? `
                                    <span style="font-size: 0.75rem; color: rgba(255, 193, 7, 0.8); margin-left: 10px;">
                                        <i class="bi bi-exclamation-triangle"></i> ${nullCount} valores nulos
                                    </span>
                                ` : ''}
                            </h5>
                            <div class="preview-table-container" style="max-height: 300px; overflow-y: auto;">
                                <table class="preview-table">
                                    <thead style="position: sticky; top: 0; background-color: var(--dark-color); z-index: 10;">
                                        <tr>
                                            <th style="width: 80px;">Índice</th>
                                            <th>Valor</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${(colData.sample || []).slice(0, 20).map((val, idx) => `
                                            <tr>
                                                <td>${idx + 1}</td>
                                                <td>${val !== null && val !== undefined ? 
                                                    (typeof val === 'number' ? val.toFixed(4) : val) : 
                                                    '<span style="color: #888; font-style: italic;">null</span>'
                                                }</td>
                                            </tr>
                                        `).join('')}
                                    </tbody>
                                </table>
                            </div>
                            ${colData.stats ? `
                                <div style="margin-top: 10px; background: rgba(0, 212, 255, 0.05); padding: 10px; border-radius: 5px;">
                                    <strong>Estadísticas:</strong><br>
                                    ${Object.entries(colData.stats).filter(([k, v]) => v !== null && typeof v !== 'object').map(([k, v]) => `
                                        ${k}: ${typeof v === 'number' ? v.toFixed(4) : v}
                                    `).join(' | ')}
                                </div>
                            ` : ''}
                        </div>
                    `;
                }
            }
            
            // Show one-hot preview if available (backward compatibility)
            if (preview.one_hot_preview) {
                bodyHtml += `
                    <h4>Vista previa (primeras 10 filas):</h4>
                    <div style="overflow-x: auto;">
                        <table class="preview-table">
                            <thead>
                                <tr>
                                    ${preview.new_columns.map(col => `<th>${col}</th>`).join('')}
                                </tr>
                            </thead>
                            <tbody>
                                ${preview.one_hot_preview.slice(0, 10).map(row => `
                                    <tr>
                                        ${preview.new_columns.map(col => `<td>${row[col]}</td>`).join('')}
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            }
        } else {
            // Normal preview
            const original = preview.original || {};
            const normalized = preview.normalized || {};
            const uniqueMapping = preview.unique_mapping || [];
            const isCategorical = preview.is_categorical || false;
            
            if (isCategorical && uniqueMapping.length > 0) {
                // Show unique value mapping for categorical data
                const totalUniqueCount = original.all_unique_count || uniqueMapping.length;
                bodyHtml = `
                    <h4>Mapeo de valores únicos (${totalUniqueCount} valores únicos totales):</h4>
                    <div class="preview-table-container" style="max-height: 600px; overflow-y: auto;">
                        <table class="preview-table">
                            <thead style="position: sticky; top: 0; background-color: rgba(0, 20, 40, 0.95); z-index: 10;">
                                <tr>
                                    <th>Valor Original</th>
                                    <th>Valor Normalizado</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${uniqueMapping.map(item => `
                                    <tr>
                                        <td>${item.original}</td>
                                        <td>${item.normalized}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                    <div style="margin-top: 20px;">
                        <h4>Muestras de datos (${(original.sample || []).length} valores):</h4>
                        <div class="preview-table-container" style="max-height: 300px; overflow-y: auto;">
                            <table class="preview-table">
                                <thead style="position: sticky; top: 0; background-color: white; z-index: 10;">
                                    <tr>
                                        <th>Índice</th>
                                        <th>Antes</th>
                                        <th>Después</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${(original.sample || []).map((val, idx) => `
                                        <tr>
                                            <td>${idx + 1}</td>
                                            <td>${val}</td>
                                            <td>${normalized.sample && normalized.sample[idx] !== undefined ? normalized.sample[idx] : 'N/A'}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            } else {
                // Regular numeric preview
                bodyHtml = `
                    <h4>Comparación antes/después (${(original.sample || []).length} muestras):</h4>
                    <div class="preview-table-container" style="max-height: 400px; overflow-y: auto;">
                        <table class="preview-table">
                            <thead style="position: sticky; top: 0; background-color: white; z-index: 10;">
                                <tr>
                                    <th>Índice</th>
                                    <th>Antes</th>
                                    <th>Después</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${(original.sample || []).map((val, idx) => `
                                    <tr>
                                        <td>${idx + 1}</td>
                                        <td>${typeof val === 'number' ? val.toFixed(4) : val}</td>
                                        <td>${normalized.sample && normalized.sample[idx] !== undefined ? 
                                            (typeof normalized.sample[idx] === 'number' ? normalized.sample[idx].toFixed(4) : normalized.sample[idx]) 
                                            : 'N/A'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            }
            
            // Añadir estadísticas si están disponibles
            if (original.stats || normalized.stats) {
                bodyHtml += `
                    <div class="stats-comparison" style="margin-top: 20px;">
                        <div class="stats-box">
                            <h4>Estadísticas Originales</h4>
                            ${original.stats ? Object.entries(original.stats).map(([key, val]) => {
                                if (typeof val === 'object' && val !== null) return '';
                                return `
                                    <div class="stat-row">
                                        <label>${key}:</label>
                                        <value>${val !== null && typeof val === 'number' ? val.toFixed(4) : val || 'N/A'}</value>
                                    </div>
                                `;
                            }).join('') : '<p>No disponibles</p>'}
                        </div>
                        <div class="stats-box">
                            <h4>Estadísticas Normalizadas</h4>
                            ${normalized.stats ? Object.entries(normalized.stats).map(([key, val]) => {
                                if (typeof val === 'object' && val !== null) return '';
                                return `
                                    <div class="stat-row">
                                        <label>${key}:</label>
                                        <value>${val !== null && typeof val === 'number' ? val.toFixed(4) : val || 'N/A'}</value>
                                    </div>
                                `;
                            }).join('') : '<p>No disponibles</p>'}
                        </div>
                    </div>
                `;
            }
        }
        
        body.innerHTML = bodyHtml;
        modal.style.display = 'block';
    }

    function closePreview() {
        document.getElementById('preview-modal').style.display = 'none';
    }

    let normalizationProcess = null;
    let progressChart = null;
    let cancelRequested = false;

    async function applyNormalization() {
        const applyBtn = document.getElementById('apply-normalization');
        applyBtn.disabled = true;
        
        const datasetName = document.getElementById('new-dataset-name').value || 
                           document.getElementById('new-dataset-name').placeholder;
        const shortDescription = document.getElementById('new-dataset-short-description').value.trim();
        const longDescription = document.getElementById('new-dataset-long-description').value.trim();
        
        // Preparar datos para el proceso
        const normalizedColumns = Object.keys(normalizationConfig);
        const totalSteps = normalizedColumns.length + 3; // +3 para: preparación, guardado, finalización
        
        // Mostrar modal de progreso
        showProgressModal(totalSteps, normalizedColumns);
        
        try {
            // Simular proceso paso a paso (en producción, esto sería asíncrono)
            await simulateNormalizationProcess(datasetName, normalizedColumns, shortDescription, longDescription);
            
        } catch (error) {
            console.error('Error completo:', error);
            hideProgressModal();
            
            // Mostrar error más específico
            let errorMessage = 'Error al aplicar normalización';
            if (error.message) {
                errorMessage = error.message;
            }
            
            showNotification(errorMessage, 'error');
            
            // Si hay log de progreso, añadir el error
            if (document.getElementById('progressLog')) {
                addProgressLog(`❌ Error: ${errorMessage}`);
            }
        } finally {
            applyBtn.disabled = false;
            applyBtn.innerHTML = '<i class="bi bi-check-circle"></i> Aplicar Normalización';
        }
    }
    
    function showProgressModal(totalSteps, columns) {
        cancelRequested = false;
        
        // Resetear UI
        document.getElementById('overallProgressBar').style.width = '0%';
        document.getElementById('overallProgressText').textContent = '0%';
        document.getElementById('currentStepText').textContent = 'Preparando normalización...';
        document.getElementById('currentStepDetails').textContent = '';
        document.getElementById('progressLog').innerHTML = '';
        
        // Inicializar gráfico
        initializeProgressChart(columns);
        
        // Mostrar modal sin backdrop
        const modalElement = document.getElementById('progressModal');
        let modal = bootstrap.Modal.getInstance(modalElement);
        
        if (!modal) {
            modal = new bootstrap.Modal(modalElement, {
                backdrop: false,  // Sin backdrop para evitar el filtro gris
                keyboard: true
            });
        }
        modal.show();
        
        // Configurar botón de cancelar
        document.getElementById('cancelNormalization').onclick = () => {
            cancelNormalization();
        };
    }
    
    function hideProgressModal() {
        const modalElement = document.getElementById('progressModal');
        const modal = bootstrap.Modal.getInstance(modalElement);
        if (modal) {
            modal.hide();
            modal.dispose();
        }
        // Clean up any lingering backdrops
        document.querySelectorAll('.modal-backdrop').forEach(backdrop => backdrop.remove());
        document.body.classList.remove('modal-open');
        document.body.style.removeProperty('overflow');
        document.body.style.removeProperty('padding-right');
    }
    
    function initializeProgressChart(columns) {
        const ctx = document.getElementById('progressChart').getContext('2d');
        
        if (progressChart) {
            progressChart.destroy();
        }
        
        const labels = ['Preparación', ...columns, 'Guardado', 'Finalización'];
        const data = new Array(labels.length).fill(0);
        
        progressChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Progreso',
                    data: data,
                    backgroundColor: 'rgba(0, 212, 255, 0.2)',
                    borderColor: 'rgba(0, 212, 255, 1)',
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        ticks: {
                            color: '#f0f9ff',
                            callback: function(value) {
                                return value + '%';
                            }
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)'
                        }
                    },
                    x: {
                        ticks: {
                            color: '#f0f9ff',
                            maxRotation: 45,
                            minRotation: 45
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.parsed.y + '% completado';
                            }
                        }
                    }
                }
            }
        });
    }
    
    async function simulateNormalizationProcess(datasetName, columns, shortDescription, longDescription) {
        const totalSteps = columns.length + 3;
        let currentStep = 0;
        
        // Paso 1: Preparación
        updateProgress(currentStep, totalSteps, 'Preparando normalización...', 'Cargando dataset y verificando configuración');
        addProgressLog('✓ Iniciando proceso de normalización');
        addProgressLog(`✓ Dataset: ${datasetInfo.dataset.name}`);
        addProgressLog(`✓ Variables a normalizar: ${columns.length}`);
        updateChartStep(0, 100);
        await delay(1000);
        
        if (cancelRequested) throw new Error('Proceso cancelado por el usuario');
        
        currentStep++;
        
        // Normalizar cada columna
        for (let i = 0; i < columns.length; i++) {
            const column = columns[i];
            const config = normalizationConfig[column];
            
            let methodDescription = '';
            if (Array.isArray(config)) {
                // Chained normalization
                const methods = config.filter(layer => layer && layer.method).map(layer => layer.method);
                methodDescription = methods.length > 1 ? 
                    `${methods.length} pasos: ${methods.join(' → ')}` : 
                    methods[0] || 'Sin método';
            } else {
                // Single normalization
                methodDescription = config.method || config;
            }
            
            updateProgress(currentStep, totalSteps, `Normalizando: ${column}`, `Método: ${methodDescription}`);
            addProgressLog(`⚙️ Normalizando "${column}" con ${methodDescription}...`);
            
            // Simular tiempo de procesamiento
            await delay(800 + Math.random() * 400);
            
            updateChartStep(i + 1, 100);
            addProgressLog(`✓ "${column}" normalizada correctamente`);
            
            if (cancelRequested) throw new Error('Proceso cancelado por el usuario');
            
            currentStep++;
        }
        
        // Paso: Guardando
        updateProgress(currentStep, totalSteps, 'Guardando dataset...', 'Escribiendo archivo CSV normalizado');
        addProgressLog('💾 Guardando dataset normalizado...');
        updateChartStep(columns.length + 1, 100);
        
        // Hacer la llamada real al servidor
        const response = await fetch(`/api/datasets/${datasetId}/normalization/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                normalization_config: normalizationConfig,
                create_copy: true,
                copy_name: datasetName,
                copy_short_description: shortDescription,
                copy_long_description: longDescription
            })
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            console.error('Error del servidor:', errorData);
            
            // Si es un error de función personalizada, mostrar en el log
            if (errorData.error_type === 'CustomFunctionError') {
                // Parsear el mensaje de error para mostrarlo línea por línea
                const errorLines = (errorData.details || errorData.message).split('\n');
                
                addProgressLog('❌ ERROR EN FUNCIÓN PERSONALIZADA');
                addProgressLog('═'.repeat(50));
                
                errorLines.forEach(line => {
                    if (line.trim()) {
                        addProgressLog(line);
                    }
                });
                
                addProgressLog('═'.repeat(50));
                addProgressLog('⚠️ El proceso de normalización ha sido detenido');
                
                // Actualizar el estado del paso actual
                document.getElementById('currentStepText').textContent = 'Error en normalización';
                document.getElementById('currentStepDetails').textContent = 'Se encontró un error al ejecutar una función personalizada';
                
                // Cambiar el botón de cancelar a cerrar
                const cancelBtn = document.getElementById('cancelNormalization');
                cancelBtn.textContent = 'Cerrar';
                cancelBtn.className = 'btn btn-secondary';
                cancelBtn.onclick = function() { hideProgressModal(); };
                
                throw new Error('Error en función personalizada');
            } else if (errorData.error && errorData.error.includes('Error de compatibilidad')) {
                // Error de compatibilidad de tipos
                addProgressLog('❌ ERROR DE COMPATIBILIDAD');
                addProgressLog('═'.repeat(50));
                addProgressLog(errorData.error);
                addProgressLog('═'.repeat(50));
                addProgressLog('⚠️ Revisa la cadena de normalización para asegurar compatibilidad entre capas');
                
                // Actualizar el estado del paso actual
                document.getElementById('currentStepText').textContent = 'Error de compatibilidad';
                document.getElementById('currentStepDetails').textContent = errorData.error;
                
                // Cambiar el botón de cancelar a cerrar
                const cancelBtn = document.getElementById('cancelNormalization');
                cancelBtn.textContent = 'Cerrar';
                cancelBtn.className = 'btn btn-secondary';
                cancelBtn.onclick = function() { hideProgressModal(); };
                
                throw new Error('Error de compatibilidad');
            } else {
                throw new Error(errorData.error || 'Error al aplicar normalización');
            }
        }
        
        const result = await response.json();
        console.log('Response from server:', result); // Debug log
        currentStep++;
        
        // Mostrar advertencias si las hay
        if (result.warnings && result.warnings.length > 0) {
            addProgressLog('⚠️ ADVERTENCIAS DE CONVERSIÓN DE TIPO:');
            result.warnings.forEach(warning => {
                addProgressLog(`   - ${warning.warning}`);
            });
        }
        
        // Paso: Finalización
        updateProgress(currentStep, totalSteps, 'Finalizando...', 'Proceso completado exitosamente');
        addProgressLog(`✓ Dataset guardado como: ${result.dataset_name}`);
        if (result.new_shape && Array.isArray(result.new_shape) && result.new_shape.length >= 2) {
            addProgressLog(`✓ Nuevas dimensiones: ${result.new_shape[0]} filas x ${result.new_shape[1]} columnas`);
        } else {
            addProgressLog(`✓ Dataset normalizado correctamente`);
        }
        updateChartStep(columns.length + 2, 100);
        
        await delay(1000);
        
        // Éxito
        hideProgressModal();
        showNotification(`Dataset normalizado creado: ${result.dataset_name}`, 'success');
        
        // Limpiar selección
        normalizationConfig = {};
        loadDatasetInfo();
        
        // Redirigir después de 2 segundos con parámetro para forzar recarga
        setTimeout(() => {
            window.location.href = `/datasets/?refresh=true`;
        }, 2000);
    }
    
    function updateProgress(current, total, stepText, details) {
        const percentage = Math.round((current / total) * 100);
        
        document.getElementById('overallProgressBar').style.width = percentage + '%';
        document.getElementById('overallProgressText').textContent = percentage + '%';
        document.getElementById('currentStepText').textContent = stepText;
        document.getElementById('currentStepDetails').textContent = details || '';
    }
    
    function updateChartStep(stepIndex, value) {
        if (progressChart) {
            progressChart.data.datasets[0].data[stepIndex] = value;
            progressChart.update();
        }
    }
    
    function addProgressLog(message, isError = false) {
        const log = document.getElementById('progressLog');
        const timestamp = new Date().toLocaleTimeString();
        let color = '#00d4ff';
        
        // Determinar el color según el tipo de mensaje
        if (isError || message.includes('ERROR') || message.includes('Error')) {
            color = '#ff6b6b';
        } else if (message.includes('⚠️') || message.includes('Warning')) {
            color = '#ffd93d';
        } else if (message.includes('✓') || message.includes('✅')) {
            color = '#6bcf7f';
        } else if (message.includes('═') || message.includes('─')) {
            color = '#666';
        } else if (message.includes('Function:') || message.includes('Error Type:') || message.includes('Traceback:')) {
            color = '#ff9ff3';
        }
        
        log.innerHTML += `<div style="color: ${color};">[${timestamp}] ${message}</div>`;
        log.scrollTop = log.scrollHeight;
    }
    
    function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    async function cancelNormalization() {
        cancelRequested = true;
        addProgressLog('❌ Cancelación solicitada por el usuario');
        
        // Aquí deberías hacer una llamada al servidor para cancelar el proceso real
        // y limpiar cualquier archivo temporal
        
        await delay(500);
        hideProgressModal();
        showNotification('Proceso de normalización cancelado', 'warning');
    }

    function renderNormalizedCopies() {
        const copyList = document.getElementById('copy-list');
        
        if (!datasetInfo.normalized_copies || datasetInfo.normalized_copies.length === 0) {
            copyList.innerHTML = '<p class="text-muted text-center">No hay copias normalizadas</p>';
            return;
        }
        
        copyList.innerHTML = datasetInfo.normalized_copies.map(copy => `
            <div class="copy-item">
                <div>
                    <div class="copy-name">${copy.name}</div>
                    <div class="copy-date">${new Date(copy.created_at).toLocaleString()}</div>
                </div>
                <div class="copy-actions">
                    <button class="copy-btn" onclick="viewDataset(${copy.id})">
                        <i class="bi bi-eye"></i> Ver
                    </button>
                    <button class="copy-btn" onclick="continueNormalization(${copy.id})">
                        <i class="bi bi-arrow-repeat"></i> Continuar
                    </button>
                </div>
            </div>
        `).join('');
    }

    function viewDataset(id) {
        // Redirigir directamente al análisis del dataset normalizado
        window.location.href = `/datasets/?open=${id}`;
    }

    function continueNormalization(id) {
        window.location.href = `/datasets/${id}/normalize/`;
    }

    function showLoadingModal(message = 'Cargando...') {
        // Crear el modal de carga si no existe
        let loadingModal = document.getElementById('loadingModal');
        if (!loadingModal) {
            loadingModal = document.createElement('div');
            loadingModal.id = 'loadingModal';
            loadingModal.className = 'modal';
            loadingModal.innerHTML = `
                <div class="modal-dialog modal-sm modal-dialog-centered">
                    <div class="modal-content" style="background: rgba(15, 17, 20, 0.95); border: 1px solid rgba(0, 212, 255, 0.3);">
                        <div class="modal-body text-center" style="padding: 30px;">
                            <div class="spinner-border text-primary mb-3" role="status" style="width: 3rem; height: 3rem;">
                                <span class="visually-hidden">Cargando...</span>
                            </div>
                            <p class="loading-message" style="color: var(--light-color); margin: 0;">${message}</p>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(loadingModal);
        } else {
            // Actualizar el mensaje
            const messageElement = loadingModal.querySelector('.loading-message');
            if (messageElement) {
                messageElement.textContent = message;
            }
        }
        
        // Mostrar el modal usando Bootstrap
        const bsModal = new bootstrap.Modal(loadingModal, {
            backdrop: 'static',
            keyboard: false
        });
        bsModal.show();
        
        return bsModal;
    }
    
    function showNotification(message, type) {
        // Implementar notificaciones toast
        const toast = document.createElement('div');
        toast.className = `toast align-items-center text-white bg-${type === 'success' ? 'success' : 'danger'} border-0`;
        toast.setAttribute('role', 'alert');
        toast.innerHTML = `
            <div class="d-flex">
                <div class="toast-body">${message}</div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
            </div>
        `;
        
        // Añadir al contenedor de toasts (crear si no existe)
        let toastContainer = document.querySelector('.toast-container');
        if (!toastContainer) {
            toastContainer = document.createElement('div');
            toastContainer.className = 'toast-container position-fixed top-0 end-0 p-3';
            document.body.appendChild(toastContainer);
        }
        
        toastContainer.appendChild(toast);
        const bsToast = new bootstrap.Toast(toast);
        bsToast.show();
    }

    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    
    // Actualizar contador de caracteres para descripción corta de normalización
    function updateNormShortCharCount() {
        const input = document.getElementById('new-dataset-short-description');
        const charCount = document.getElementById('normShortCharCount');
        if (input && charCount) {
            const current = input.value.length;
            charCount.textContent = `(${current}/80)`;
            charCount.style.color = current >= 80 ? '#ff6b6b' : '#6c757d';
        }
    }

    // Event listeners
    document.getElementById('apply-normalization').addEventListener('click', applyNormalization);
    
    // Cerrar modal al hacer clic fuera
    window.onclick = function(event) {
        const modal = document.getElementById('preview-modal');
        if (event.target === modal) {
            closePreview();
        }
    }
    
    
    function openCustomFunctionModal(functionData = null) {
        const modal = new bootstrap.Modal(document.getElementById('customFunctionModal'));
        const modalTitle = document.querySelector('#customFunctionModal .modal-title');
        
        if (functionData) {
            // Modo edición
            console.log('Opening modal for edit mode with data:', functionData);
            console.log('Column control data:', {
                remove_original_column: functionData.remove_original_column,
                new_columns: functionData.new_columns
            });
            modalTitle.innerHTML = '<i class="bi bi-pencil-square"></i> Editar Función de Normalización Personalizada';
            
            // Guardar el ID y el tipo original ANTES de cualquier otra operación
            document.getElementById('customFunctionModal').dataset.editingId = functionData.id;
            document.getElementById('customFunctionModal').dataset.originalType = functionData.function_type;
            
            // Primero establecer el tipo de función (sin actualizar el código)
            selectFunctionType(functionData.function_type, true);
            
            // Luego establecer los valores
            document.getElementById('functionName').value = functionData.name;
            document.getElementById('functionDescription').value = functionData.description;
            
            // Cargar configuración de columnas
            document.getElementById('numNewColumns').value = functionData.new_columns && functionData.new_columns.length > 0 ? functionData.new_columns.length : 1;
            
            // Cargar nombres de columnas existentes
            if (functionData.new_columns && functionData.new_columns.length > 0) {
                detectedColumnNames = functionData.new_columns;
                console.log('Loaded existing column names:', detectedColumnNames);
            }
            
            // Actualizar los inputs de columnas antes de establecer sus valores
            updateNewColumnsInputs();
            
            // Establecer el código después de un pequeño delay para asegurar que no se sobrescriba
            setTimeout(() => {
                document.getElementById('functionCode').value = functionData.code;
                
                // Verificar que el código se cargó correctamente
                console.log('Code loaded into textarea:', document.getElementById('functionCode').value.substring(0, 200) + '...');
                console.log('Original code:', functionData.code.substring(0, 200) + '...');
                
                // Ya no necesitamos cargar los nombres de columnas ya que no hay inputs
                
                // Forzar un evento de cambio para actualizar cualquier listener
                const event = new Event('input', { bubbles: true });
                document.getElementById('functionCode').dispatchEvent(event);
            }, 100);
            
            console.log('Modal data set - ID:', functionData.id, 'Type:', functionData.function_type);
        } else {
            // Modo creación
            console.log('Opening modal for create mode');
            modalTitle.innerHTML = '<i class="bi bi-code-slash"></i> Crear Función de Normalización Personalizada';
            document.getElementById('functionName').value = '';
            document.getElementById('functionDescription').value = '';
            document.getElementById('numNewColumns').value = '1';
            updateNewColumnsInputs();
            updateCodeExample();
            
            // Limpiar nombres detectados
            detectedColumnNames = [];
            
            // Eliminar el ID de edición si existe
            delete document.getElementById('customFunctionModal').dataset.editingId;
            delete document.getElementById('customFunctionModal').dataset.originalType;
        }
        
        modal.show();
        
        // Establecer código de ejemplo según el tipo seleccionado
        updateCodeExample();
        
        // Poblar el selector de columnas
        populateColumnSelector();
    }
    
    function selectFunctionType(type, skipCodeUpdate = false) {
        selectedFunctionType = type;
        
        // Actualizar visual
        document.querySelectorAll('.function-type-option').forEach(opt => {
            opt.classList.remove('active');
        });
        const typeSelector = document.querySelector(`[data-type="${type}"]`);
        if (typeSelector) {
            typeSelector.classList.add('active');
        }
        
        // NO actualizar el código si ya hay código escrito
        const currentCode = document.getElementById('functionCode').value;
        const isEditMode = skipCodeUpdate || document.getElementById('customFunctionModal').dataset.editingId;
        
        // Solo actualizar el código si está vacío o es el código de ejemplo por defecto
        if (!isEditMode && (!currentCode || currentCode.trim() === '')) {
            updateCodeExample();
        }
        
        // Repoblar el selector de columnas con el nuevo tipo
        populateColumnSelector();
        
        // Limpiar valores del datalist si existe
        const datasetValuesList = document.getElementById('datasetValuesList');
        if (datasetValuesList) {
            datasetValuesList.innerHTML = '';
        }
        
        const testValueInput = document.getElementById('testValue');
        if (testValueInput) {
            testValueInput.value = '';
        }
    }
    
    function updateNewColumnsInputs() {
        const numColumns = parseInt(document.getElementById('numNewColumns').value) || 1;
        const container = document.getElementById('newColumnsContainer');
        container.innerHTML = '';
        
        // No mostrar inputs de nombres de columnas
        // Los nombres se generarán automáticamente como columna_1, columna_2, etc.
        
        // Actualizar el ejemplo de código con la nueva estructura
        updateCodeExample();
    }
    
    function getColumnNameSuggestion(index) {
        const suggestions = [
            'columna_normalizada',
            'categoria_codificada',
            'valor_procesado',
            'feature_extraida',
            'componente_principal'
        ];
        return suggestions[(index - 1) % suggestions.length] + (index > suggestions.length ? index : '');
    }
    
    function updateCodeExample() {
        // No actualizar si estamos en modo edición
        if (document.getElementById('customFunctionModal').dataset.editingId) {
            console.log('Skipping code update - in edit mode');
            return;
        }
        
        const codeEditor = document.getElementById('functionCode');
        const numColumns = parseInt(document.getElementById('numNewColumns').value) || 1;
        
        console.log('Updating code example for type:', selectedFunctionType);
        
        if (selectedFunctionType === 'numeric') {
            if (numColumns === 1) {
                codeEditor.value = `# Los imports son opcionales - los módulos también están disponibles directamente
# import math
# from datetime import datetime

def normalize(value, series=None):
    """
    Normaliza valores numéricos
    Args:
        value: El valor individual a normalizar
        series: La serie completa de la columna (opcional)
    Returns:
        El valor normalizado para la nueva columna
    """
    # Ejemplo: normalización min-max
    if series is not None:
        min_val = series.min()
        max_val = series.max()
        if max_val - min_val > 0:
            return (value - min_val) / (max_val - min_val)
    return value`;
            } else {
                // Generar ejemplo para múltiples columnas
                const columnNames = [];
                for (let i = 1; i <= numColumns; i++) {
                    const inputName = document.getElementById(`newColumnName${i}`)?.value || `columna_${i}`;
                    columnNames.push(`'${inputName}'`);
                }
                
                codeEditor.value = `def normalize(value, series=None):
    """
    Normaliza valores numéricos y crea múltiples columnas nuevas
    Args:
        value: El valor individual a normalizar
        series: La serie completa de la columna (opcional)
    Returns:
        dict: Diccionario con los valores para cada columna nueva
              Las claves deben ser: ${columnNames.join(', ')}
    """
    # Ejemplo: crear múltiples features a partir del valor original
    result = {}
    
    if series is not None:
        min_val = series.min()
        max_val = series.max()
        
        # Columna 1: Normalización min-max
        if max_val - min_val > 0:
            result['${columnNames[0].replace(/'/g, '')}'] = (value - min_val) / (max_val - min_val)
        else:
            result['${columnNames[0].replace(/'/g, '')}'] = 0
        
        # Columna 2: Normalización z-score
        if len(series) > 1:
            mean_val = series.mean()
            std_val = series.std()
            if std_val > 0:
                result['${columnNames[1] ? columnNames[1].replace(/'/g, '') : 'columna_2'}'] = (value - mean_val) / std_val
            else:
                result['${columnNames[1] ? columnNames[1].replace(/'/g, '') : 'columna_2'}'] = 0
    else:
        # Sin la serie completa, retornar valores por defecto
        ${columnNames.map((col, i) => `result[${col}] = value`).join('\n        ')}
    
    return result`;
            }
        } else {
            if (numColumns === 1) {
                codeEditor.value = `def normalize(value):
    """
    Normaliza valores de texto
    Args:
        value: El valor de texto a normalizar
    Returns:
        El texto normalizado para la nueva columna
    """
    # Ejemplo: limpieza de texto
    if isinstance(value, str):
        # Eliminar espacios extras y convertir a minúsculas
        return value.strip().lower().replace('  ', ' ')
    return value`;
            } else {
                // Generar ejemplo para múltiples columnas de texto
                const columnNames = [];
                for (let i = 1; i <= numColumns; i++) {
                    const inputName = document.getElementById(`newColumnName${i}`)?.value || `columna_${i}`;
                    columnNames.push(`'${inputName}'`);
                }
                
                codeEditor.value = `def normalize(value):
    """
    Normaliza valores de texto y crea múltiples columnas nuevas
    Args:
        value: El valor de texto a normalizar
    Returns:
        dict: Diccionario con los valores para cada columna nueva
              Las claves deben ser: ${columnNames.join(', ')}
    """
    # Ejemplo: extraer diferentes características del texto
    result = {}
    
    if isinstance(value, str):
        # Columna 1: Texto limpio en minúsculas
        result['${columnNames[0].replace(/'/g, '')}'] = value.strip().lower().replace('  ', ' ')
        
        # Columna 2: Longitud del texto
        result['${columnNames[1] ? columnNames[1].replace(/'/g, '') : 'columna_2'}'] = len(value.strip())
        
        # Agregar más transformaciones según sea necesario
        ${columnNames.slice(2).map((col, i) => `result[${col}] = value  # Transformación ${i + 3}`).join('\n        ')}
    else:
        # Si no es texto, retornar valores por defecto
        ${columnNames.map((col, i) => `result[${col}] = ''`).join('\n        ')}
    
    return result`;
            }
        }
    }
    
    function populateColumnSelector() {
        const columnSelector = document.getElementById('columnSelector');
        columnSelector.innerHTML = '<option value="">Seleccionar columna...</option>';
        
        if (datasetInfo && datasetInfo.normalization_info) {
            // Separar columnas por tipo
            const numericColumns = [];
            const textColumns = [];
            const otherColumns = [];
            
            for (const [column, info] of Object.entries(datasetInfo.normalization_info)) {
                if (info.type === 'numeric') {
                    numericColumns.push({ name: column, type: 'Numérico' });
                } else if (info.type === 'text') {
                    textColumns.push({ name: column, type: 'Texto' });
                } else {
                    otherColumns.push({ name: column, type: 'Otro' });
                }
            }
            
            // Agregar columnas numéricas
            if (numericColumns.length > 0) {
                columnSelector.innerHTML += '<optgroup label="Columnas Numéricas">';
                numericColumns.forEach(col => {
                    columnSelector.innerHTML += `<option value="${col.name}">${col.name}</option>`;
                });
                columnSelector.innerHTML += '</optgroup>';
            }
            
            // Agregar columnas de texto
            if (textColumns.length > 0) {
                columnSelector.innerHTML += '<optgroup label="Columnas de Texto">';
                textColumns.forEach(col => {
                    columnSelector.innerHTML += `<option value="${col.name}">${col.name}</option>`;
                });
                columnSelector.innerHTML += '</optgroup>';
            }
            
            // Agregar otras columnas
            if (otherColumns.length > 0) {
                columnSelector.innerHTML += '<optgroup label="Otras Columnas">';
                otherColumns.forEach(col => {
                    columnSelector.innerHTML += `<option value="${col.name}">${col.name}</option>`;
                });
                columnSelector.innerHTML += '</optgroup>';
            }
        }
    }
    
    let currentColumnData = null;
    
    async function updateDatasetValues() {
        const columnName = document.getElementById('columnSelector').value;
        const columnTestButtons = document.getElementById('columnTestButtons');
        
        currentColumnData = null;
        
        if (!columnName) {
            columnTestButtons.style.display = 'none';
            return;
        }
        
        try {
            // Obtener valores únicos de la columna
            const response = await fetch(`/api/datasets/${datasetId}/columns/${encodeURIComponent(columnName)}/`);
            if (response.ok) {
                const data = await response.json();
                currentColumnData = data;
                
                // Mostrar botones de prueba
                columnTestButtons.style.display = 'block';
            }
        } catch (error) {
            console.error('Error loading column values:', error);
            showNotification('Error al cargar datos de la columna', 'error');
        }
    }
    
    async function testWithManualValue() {
        const testValue = document.getElementById('testValue').value;
        
        if (!testValue) {
            showNotification('Por favor ingresa un valor de prueba', 'warning');
            return;
        }
        
        await testCustomFunction(testValue, 'manualTestResult');
    }
    
    async function testFirst20Values() {
        const columnName = document.getElementById('columnSelector').value;
        if (!columnName || !currentColumnData) {
            showNotification('Por favor selecciona una columna primero', 'warning');
            return;
        }
        
        const functionCode = document.getElementById('functionCode').value;
        if (!functionCode.trim()) {
            showNotification('Por favor escribe el código de la función primero', 'warning');
            return;
        }
        
        // Obtener los primeros 20 valores
        let valuesToTest = [];
        
        // Intentar obtener valores de diferentes formas según la estructura de los datos
        // Priorizar frequency_data ya que contiene todos los valores únicos
        if (currentColumnData.frequency_data && Array.isArray(currentColumnData.frequency_data)) {
            // frequency_data contiene objetos con {value: x, count: y}, tomar los primeros 20 valores
            valuesToTest = currentColumnData.frequency_data.slice(0, 20).map(item => item.value || item);
        } else if (currentColumnData.unique_values && Array.isArray(currentColumnData.unique_values)) {
            valuesToTest = currentColumnData.unique_values.slice(0, 20);
        } else if (currentColumnData.value_counts) {
            valuesToTest = Object.keys(currentColumnData.value_counts).slice(0, 20);
        } else if (currentColumnData.sample_values && Array.isArray(currentColumnData.sample_values)) {
            // sample_values como último recurso ya que puede tener pocos valores
            valuesToTest = currentColumnData.sample_values.slice(0, 20);
        }
        
        if (valuesToTest.length === 0) {
            showNotification('No se encontraron valores en la columna', 'warning');
            return;
        }
        
        // Ejecutar la función en cada valor
        const results = await testMultipleValues(valuesToTest);
        displayMultipleResults(results, `Primeros ${valuesToTest.length} valores de "${columnName}"`, 'columnTestResult');
    }
    
    async function testAllUniqueValues() {
        const columnName = document.getElementById('columnSelector').value;
        if (!columnName || !currentColumnData) {
            showNotification('Por favor selecciona una columna primero', 'warning');
            return;
        }
        
        // Obtener todos los valores únicos
        let allValues = [];
        
        // Intentar obtener valores de diferentes formas según la estructura de los datos
        // Priorizar frequency_data ya que contiene todos los valores únicos
        if (currentColumnData.frequency_data && Array.isArray(currentColumnData.frequency_data)) {
            // frequency_data contiene todos los valores únicos con su frecuencia
            allValues = currentColumnData.frequency_data.map(item => item.value !== undefined ? item.value : item);
        } else if (currentColumnData.unique_values && Array.isArray(currentColumnData.unique_values)) {
            allValues = currentColumnData.unique_values;
        } else if (currentColumnData.value_counts) {
            allValues = Object.keys(currentColumnData.value_counts);
        } else if (currentColumnData.sample_values && Array.isArray(currentColumnData.sample_values)) {
            // Si solo tenemos una muestra, obtener valores únicos de ella
            allValues = [...new Set(currentColumnData.sample_values)];
        }
        
        if (allValues.length === 0) {
            showNotification('No se encontraron valores únicos en la columna', 'warning');
            return;
        }
        
        // Mostrar loading
        const resultDiv = document.getElementById('columnTestResult');
        resultDiv.className = 'test-result mt-3';
        resultDiv.innerHTML = '<div class="text-center"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">Procesando...</span></div><p class="mt-2">Probando ' + allValues.length + ' valores únicos...</p></div>';
        resultDiv.style.display = 'block';
        
        // Ejecutar la función en cada valor
        const results = await testMultipleValues(allValues);
        displayMultipleResults(results, `Todos los valores únicos de ${columnName} (${allValues.length} valores)`, 'columnTestResult');
    }
    
    async function testMultipleValues(values) {
        const functionCode = document.getElementById('functionCode').value;
        const results = [];
        
        for (const value of values) {
            try {
                const response = await fetch('/api/custom-normalization-functions/test/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        code: functionCode,
                        test_value: value,
                        function_type: selectedFunctionType
                    })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    results.push({
                        input: value,
                        output: result.result,
                        success: true
                    });
                } else {
                    results.push({
                        input: value,
                        output: result.error,
                        success: false
                    });
                }
            } catch (error) {
                results.push({
                    input: value,
                    output: error.message,
                    success: false
                });
            }
        }
        
        return results;
    }
    
    function displayMultipleResults(results, title, resultDivId = 'columnTestResult') {
        const resultDiv = document.getElementById(resultDivId);
        
        const successCount = results.filter(r => r.success).length;
        const errorCount = results.length - successCount;
        
        let html = `<h6>${title} <small class="text-muted">(${new Date().toLocaleTimeString()})</small></h6>`;
        html += `<p class="mb-2">✅ Exitosos: ${successCount} | ❌ Errores: ${errorCount}</p>`;
        
        html += '<table class="test-result-table">';
        html += '<thead><tr><th>Valor Original</th><th>Resultado</th><th>Estado</th></tr></thead>';
        html += '<tbody>';
        
        results.forEach(result => {
            const statusIcon = result.success ? '✅' : '❌';
            const rowClass = result.success ? '' : 'style="color: #ff6b6b;"';
            html += `<tr ${rowClass}>`;
            html += `<td><code>${result.input}</code></td>`;
            html += `<td><code>${result.output}</code></td>`;
            html += `<td>${statusIcon}</td>`;
            html += '</tr>';
        });
        
        html += '</tbody></table>';
        
        resultDiv.className = 'test-result success mt-3';
        resultDiv.innerHTML = html;
        resultDiv.style.display = 'block';
        
        // Hacer scroll al resultado
        resultDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
    
    async function testCustomFunction(testValue, resultDivId = 'manualTestResult') {
        const functionCode = document.getElementById('functionCode').value;
        const resultDiv = document.getElementById(resultDivId);
        
        if (!functionCode.trim()) {
            showNotification('Por favor escribe el código de la función primero', 'warning');
            return;
        }
        
        if (!testValue) {
            showNotification('Por favor proporciona un valor de prueba', 'warning');
            return;
        }
        
        // Ocultar y mostrar el div para forzar la actualización visual
        resultDiv.style.display = 'none';
        
        // Mostrar un loading mientras se procesa
        resultDiv.className = 'test-result mt-3';
        resultDiv.innerHTML = '<div class="text-center"><div class="spinner-border spinner-border-sm" role="status"></div> Procesando...</div>';
        resultDiv.style.display = 'block';
        
        try {
            const response = await fetch('/api/custom-normalization-functions/test/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    code: functionCode,
                    test_value: testValue,
                    function_type: selectedFunctionType
                })
            });
            
            const result = await response.json();
            
            if (response.ok) {
                // Store detected column names
                if (result.detected_columns && result.detected_columns.length > 0) {
                    detectedColumnNames = result.detected_columns;
                    console.log('Detected column names:', detectedColumnNames);
                    
                    // Update the number of columns input
                    document.getElementById('numNewColumns').value = detectedColumnNames.length;
                }
                
                resultDiv.className = 'test-result success mt-3';
                let html = `
                    <h6>Resultado de la prueba <small class="text-muted">(${new Date().toLocaleTimeString()})</small></h6>
                    <table class="test-result-table">
                        <tr>
                            <th>Valor de entrada</th>
                            <td><code>${testValue}</code></td>
                        </tr>
                `;
                
                // Si el resultado es un objeto/diccionario (múltiples columnas)
                if (typeof result.result === 'object' && result.result !== null) {
                    html += `
                        <tr>
                            <th colspan="2" class="text-center">Resultados por columna:</th>
                        </tr>
                    `;
                    
                    // Mostrar cada columna y su valor
                    for (const [columnName, value] of Object.entries(result.result)) {
                        html += `
                            <tr>
                                <th class="ps-4">${columnName}</th>
                                <td><code>${value}</code></td>
                            </tr>
                        `;
                    }
                } else {
                    // Resultado simple
                    html += `
                        <tr>
                            <th>Resultado</th>
                            <td><code>${result.result}</code></td>
                        </tr>
                    `;
                }
                
                if (detectedColumnNames.length > 0) {
                    html += `
                        <tr>
                            <th>Columnas detectadas</th>
                            <td>
                                <div class="d-flex flex-wrap gap-1">
                                    ${detectedColumnNames.map(col => `<span class="badge bg-info">${col}</span>`).join('')}
                                </div>
                            </td>
                        </tr>
                    `;
                }
                
                html += '</table>';
                
                // Agregar botón para probar de nuevo
                html += `
                    <div class="mt-2 text-center">
                        <button class="btn btn-sm btn-outline-primary" onclick="testWithManualValue()">
                            <i class="bi bi-arrow-clockwise"></i> Probar de nuevo
                        </button>
                    </div>
                `;
                
                resultDiv.innerHTML = html;
                resultDiv.style.display = 'block';
                
                // Hacer scroll al resultado
                resultDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            } else {
                resultDiv.className = 'test-result error mt-3';
                resultDiv.innerHTML = `<strong>Error:</strong> ${result.error}`;
                resultDiv.style.display = 'block';
            }
        } catch (error) {
            resultDiv.className = 'test-result error mt-3';
            resultDiv.innerHTML = `<strong>Error:</strong> ${error.message}`;
            resultDiv.style.display = 'block';
        }
    }
    
    async function saveCustomFunction() {
        const name = document.getElementById('functionName').value.trim();
        const description = document.getElementById('functionDescription').value.trim();
        const code = document.getElementById('functionCode').value; // No trim para preservar el formato exacto
        const editingId = document.getElementById('customFunctionModal').dataset.editingId;
        
        if (!name || !description || !code) {
            showNotification('Por favor completa todos los campos', 'warning');
            return;
        }
        
        try {
            const url = editingId 
                ? `/api/custom-normalization-functions/${editingId}/`
                : '/api/custom-normalization-functions/';
            
            const method = editingId ? 'PUT' : 'POST';
            
            // Recopilar información de las nuevas columnas
            const numNewColumns = parseInt(document.getElementById('numNewColumns').value) || 1;
            let newColumns = [];
            
            // Usar nombres detectados si están disponibles
            if (detectedColumnNames.length > 0) {
                newColumns = detectedColumnNames;
                console.log('Using detected column names:', newColumns);
            } else {
                // Generar nombres automáticos solo si no hay nombres detectados
                for (let i = 1; i <= numNewColumns; i++) {
                    newColumns.push(`columna_${i}`);
                }
            }
            
            const requestData = {
                name: name,
                description: description,
                code: code,
                function_type: selectedFunctionType,
                new_columns: newColumns
            };
            
            console.log('Saving function:', {
                url: url,
                method: method,
                data: requestData,
                codeLength: code.length,
                editingId: editingId,
                codePreview: code.substring(0, 200) + '...'
            });
            
            // Verificar una vez más que el código es el correcto antes de enviar
            console.log('Final code check before sending:');
            console.log('  Code starts with:', code.substring(0, 50));
            console.log('  Code ends with:', code.substring(code.length - 50));
            
            // Verificar que el código del textarea es el correcto
            const textareaCode = document.getElementById('functionCode').value;
            console.log('Code from textarea:', textareaCode.substring(0, 200) + '...');
            console.log('Codes match:', code === textareaCode);
            
            const response = await fetch(url, {
                method: method,
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify(requestData)
            });
            
            if (response.ok) {
                const result = await response.json();
                console.log('Function saved/updated:', result);
                console.log('Returned code preview:', result.code ? result.code.substring(0, 200) + '...' : 'No code returned');
                console.log('Returned code length:', result.code ? result.code.length : 0);
                
                // Verificar que el código devuelto coincide con el enviado
                if (result.code !== code) {
                    console.warn('WARNING: Returned code does not match sent code!');
                    console.log('Sent code length:', code.length);
                    console.log('Returned code length:', result.code ? result.code.length : 0);
                }
                
                showNotification(
                    editingId ? 'Función actualizada exitosamente' : 'Función guardada exitosamente', 
                    'success'
                );
                
                // Cerrar modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('customFunctionModal'));
                modal.hide();
                
                // Forzar recarga completa de datos sin cache
                await new Promise(resolve => setTimeout(resolve, 500)); // Pequeña pausa para asegurar que el backend procesó todo
                
                // Recargar funciones y actualizar UI
                await loadDatasetInfo();
                renderVariables();
                
                // Si hay un modal de gestión abierto, recargarlo también
                if (document.getElementById('manageFunctionsModal').classList.contains('show')) {
                    await loadFunctionsForManagement();
                }
                
                // Limpiar formulario
                document.getElementById('functionName').value = '';
                document.getElementById('functionDescription').value = '';
                updateCodeExample();
                
                // Eliminar el ID de edición
                delete document.getElementById('customFunctionModal').dataset.editingId;
            } else {
                const error = await response.json();
                console.error('Error saving function:', error);
                let errorMessage = editingId ? 'Error al actualizar la función' : 'Error al guardar la función';
                if (error.name && error.name[0]) {
                    errorMessage = `Error en el nombre: ${error.name[0]}`;
                } else if (error.error) {
                    errorMessage = error.error;
                } else if (error.detail) {
                    errorMessage = error.detail;
                }
                showNotification(errorMessage, 'error');
            }
        } catch (error) {
            showNotification('Error de conexión', 'error');
        }
    }
    
    // Modificar la función createVariableCard para incluir funciones personalizadas
    // COMENTADO: Esta función duplicada sobrescribe la nueva implementación con capas
    /*
    function createVariableCard(column, info) {
        console.log(`Creating card for ${column}:`, info);
        console.log(`Primary methods:`, info.primary_methods);
        console.log(`Secondary methods:`, info.secondary_methods);
        
        const card = document.createElement('div');
        card.className = 'variable-card';
        
        // Determinar el tipo de badge
        const typeClass = `type-${info.type}`;
        const typeLabel = info.type === 'numeric' ? 'Numérico' : 
                         info.type === 'text' ? 'Texto' : 'Desconocido';
        
        // Crear contenido de estadísticas
        let statsHtml = '';
        if (info.type === 'numeric' && info.stats) {
            statsHtml = `
                <div class="variable-stats">
                    ${info.stats.mean !== null ? `Media: ${info.stats.mean.toFixed(2)}` : ''}
                    ${info.stats.std !== null ? ` | Desv: ${info.stats.std.toFixed(2)}` : ''}<br>
                    ${info.stats.min !== null ? `Min: ${info.stats.min.toFixed(2)}` : ''}
                    ${info.stats.max !== null ? ` | Max: ${info.stats.max.toFixed(2)}` : ''}
                </div>
            `;
        } else if (info.type === 'text' && info.stats) {
            statsHtml = `
                <div class="variable-stats">
                    ${info.stats.unique_count} valores únicos<br>
                    ${info.stats.sample_values ? `Ej: ${info.stats.sample_values.slice(0, 2).join(', ')}...` : ''}
                </div>
            `;
        }
        
        card.innerHTML = `
            <div class="variable-header">
                <span class="variable-name">${column}</span>
                <span class="variable-type ${typeClass}">${typeLabel}</span>
            </div>
            ${statsHtml}
            <select class="normalization-select" id="norm-${column}" onchange="onNormalizationChange('${column}')">
                <option value="">Sin normalizar</option>
                <optgroup label="Métodos principales">
                    ${info.primary_methods.map(method => 
                        `<option value="${method.value}" title="${method.description}">${method.label}</option>`
                    ).join('')}
                </optgroup>
                ${info.secondary_methods.length > 0 ? `
                    <optgroup label="Otros métodos">
                        ${info.secondary_methods.map(method => 
                            `<option value="${method.value}" title="${method.description}">${method.label}</option>`
                        ).join('')}
                    </optgroup>
                ` : ''}
            </select>
            <div class="keep-original-container" id="keep-original-${column}" style="display: none;">
                <label class="keep-original-label">
                    <input type="checkbox" class="keep-original-checkbox" id="keep-original-checkbox-${column}" 
                           onchange="onKeepOriginalChange('${column}')" checked>
                    <span>Mantener columna original</span>
                </label>
            </div>
            <button class="preview-btn" onclick="previewNormalization('${column}')" 
                    id="preview-btn-${column}" style="display: none;">
                <i class="bi bi-eye"></i> Previsualizar
            </button>
        `;
        
        return card;
    }
    */
    
    function showPreviewError(errorMessage) {
        const modal = document.getElementById('preview-modal');
        const body = document.getElementById('preview-body');
        const title = document.getElementById('preview-title');
        
        title.innerHTML = '<i class="bi bi-exclamation-triangle-fill text-danger"></i> Error en Función Personalizada';
        
        // Parsear el mensaje de error para mostrarlo línea por línea
        const errorLines = errorMessage.split('\n');
        
        let bodyHtml = `
            <div class="error-console" style="background-color: #1a1a1a; color: #f0f0f0; padding: 20px; border-radius: 8px; font-family: 'Consolas', 'Monaco', monospace; font-size: 14px; overflow-x: auto;">
                <div style="color: #ff6b6b; margin-bottom: 10px;">
                    <i class="bi bi-terminal"></i> ERROR DE EJECUCIÓN
                </div>
                <div style="border-top: 1px solid #444; margin: 10px 0;"></div>
        `;
        
        errorLines.forEach(line => {
            if (line.trim()) {
                let lineColor = '#f0f0f0';
                
                // Colorear diferentes tipos de líneas
                if (line.includes('Error Type:') || line.includes('Function:')) {
                    lineColor = '#ff9ff3';
                } else if (line.includes('Error Message:')) {
                    lineColor = '#ff6b6b';
                } else if (line.includes('Traceback:')) {
                    lineColor = '#ffd93d';
                } else if (line.includes('File') && line.includes('line')) {
                    lineColor = '#6bcf7f';
                }
                
                bodyHtml += `<div style="color: ${lineColor}; margin: 2px 0;">${line}</div>`;
            }
        });
        
        bodyHtml += `
                <div style="border-top: 1px solid #444; margin: 10px 0;"></div>
                <div style="color: #ffd93d; margin-top: 10px;">
                    <i class="bi bi-lightbulb"></i> Revisa tu función y asegúrate de que maneje correctamente el tipo de datos de la columna.
                </div>
            </div>
        `;
        
        body.innerHTML = bodyHtml;
        
        // Mostrar el modal
        const modalBS = new bootstrap.Modal(modal);
        modalBS.show();
        
        // Asegurar que se elimine la clase modal-open al cerrar
        modal.addEventListener('hidden.bs.modal', function () {
            document.body.classList.remove('modal-open');
            document.body.style.overflow = '';
            document.body.style.paddingRight = '';
            
            // Eliminar cualquier backdrop que haya quedado
            const backdrops = document.querySelectorAll('.modal-backdrop');
            backdrops.forEach(backdrop => backdrop.remove());
        });
    }
    
    async function openManageFunctionsModal() {
        const modal = new bootstrap.Modal(document.getElementById('manageFunctionsModal'));
        modal.show();
        
        // Cargar funciones
        await loadFunctionsForManagement();
    }
    
    async function loadFunctionsForManagement() {
        const functionsList = document.getElementById('functionsList');
        functionsList.innerHTML = '<div class="text-center"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">Cargando...</span></div></div>';
        
        try {
            // Agregar timestamp para evitar cache
            const timestamp = new Date().getTime();
            const response = await fetch(`/api/custom-normalization-functions/?t=${timestamp}`, {
                cache: 'no-store',
                headers: {
                    'Cache-Control': 'no-cache',
                    'Pragma': 'no-cache'
                }
            });
            if (response.ok) {
                const functions = await response.json();
                
                if (functions.length === 0) {
                    functionsList.innerHTML = `
                        <div class="text-center text-muted" style="padding: 50px;">
                            <i class="bi bi-inbox" style="font-size: 3rem;"></i>
                            <p class="mt-3">No hay funciones personalizadas creadas aún.</p>
                        </div>
                    `;
                } else {
                    functionsList.innerHTML = functions.map(func => {
                        const safeName = func.name.replace(/'/g, "\\'").replace(/"/g, '\\"');
                        return `
                            <div class="function-item">
                                <div class="function-header">
                                    <div>
                                        <span class="function-name">${func.name}</span>
                                        <span class="function-type">${func.function_type === 'numeric' ? 'Numérica' : 'Texto'}</span>
                                    </div>
                                    <div class="function-actions">
                                        <button onclick="editFunction(${func.id})" title="Editar">
                                            <i class="bi bi-pencil"></i> Editar
                                        </button>
                                        <button onclick="deleteFunction(${func.id}, '${safeName}')" class="delete-btn" title="Eliminar">
                                            <i class="bi bi-trash"></i> Eliminar
                                        </button>
                                    </div>
                                </div>
                                <div class="function-description" style="color: rgba(240, 249, 255, 0.7); font-size: 0.9rem;">
                                    ${func.description || 'Sin descripción'}
                                </div>
                                <div class="function-code mt-2" style="background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 5px; font-family: monospace; font-size: 0.85rem; max-height: 200px; overflow-y: auto;">
                                    <pre style="margin: 0; color: #00d4ff;">${escapeHtml(func.code)}</pre>
                                </div>
                            </div>
                        `;
                    }).join('');
                }
            }
        } catch (error) {
            console.error('Error loading functions:', error);
            functionsList.innerHTML = '<div class="alert alert-danger">Error al cargar las funciones</div>';
        }
    }
    
    function escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, m => map[m]);
    }
    
    // Hacer las funciones globales para que puedan ser llamadas desde el HTML generado dinámicamente
    function showColumnDetails(column, layerIndex) {
        const escapedColumn = column.replace(/['"\\]/g, '\\$&').replace(/\s/g, '_');
        const outputIndicator = document.getElementById(`output-type-${escapedColumn}-${layerIndex}`);
        
        if (!outputIndicator) return;
        
        const customFunctionId = outputIndicator.dataset.customFunctionId;
        const expectedColumns = JSON.parse(outputIndicator.dataset.expectedColumns || '[]');
        
        // Mostrar modal de carga
        const loadingModal = showLoadingModal('Obteniendo detalles de columnas...');
        
        // Construir la configuración de normalización para esta columna
        const currentConfig = {};
        if (normalizationConfig[column] && normalizationConfig[column][layerIndex]) {
            currentConfig[column] = [normalizationConfig[column][layerIndex]];
        }
        
        // Hacer preview para obtener los tipos detectados
        fetch(`/api/datasets/${datasetId}/normalization/preview/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                normalization: currentConfig,
                sample_size: 10  // Solo necesitamos una pequeña muestra
            })
        })
        .then(response => response.json())
        .then(data => {
            loadingModal.hide();
            
            // Crear el contenido del modal
            let columnsHtml = '';
            
            if (data.preview && data.preview[column] && data.preview[column].column_types_info) {
                // Usar la información de tipos detectados
                const columnTypesInfo = data.preview[column].column_types_info;
                
                columnsHtml = `
                    <div class="column-details-container">
                        <h5 style="color: var(--primary-color); margin-bottom: 20px;">
                            <i class="bi bi-table"></i> Columnas generadas por la función
                        </h5>
                        <div class="columns-list" style="max-height: 400px; overflow-y: auto;">
                `;
                
                columnTypesInfo.forEach((colInfo, idx) => {
                    // Determine type class and icon based on specific type
                    let typeClass = 'text';
                    let typeIcon = 'bi-fonts';
                    let typeLabel = 'Texto';
                    let typeColor = 'rgba(255, 107, 107, 0.5)';
                    
                    switch(colInfo.type) {
                        case 'integer':
                            typeClass = 'numeric';
                            typeIcon = 'bi-123';
                            typeLabel = 'Entero';
                            typeColor = 'rgba(0, 212, 255, 0.5)';
                            break;
                        case 'float':
                            typeClass = 'numeric';
                            typeIcon = 'bi-percent';
                            typeLabel = 'Decimal';
                            typeColor = 'rgba(0, 212, 255, 0.5)';
                            break;
                        case 'boolean':
                            typeClass = 'boolean';
                            typeIcon = 'bi-toggle-on';
                            typeLabel = 'Booleano';
                            typeColor = 'rgba(147, 51, 234, 0.5)';
                            break;
                        case 'datetime':
                            typeClass = 'datetime';
                            typeIcon = 'bi-calendar-date';
                            typeLabel = 'Fecha/Hora';
                            typeColor = 'rgba(255, 193, 7, 0.5)';
                            break;
                        case 'numeric':
                            typeClass = 'numeric';
                            typeIcon = 'bi-123';
                            typeLabel = 'Numérico';
                            typeColor = 'rgba(0, 212, 255, 0.5)';
                            break;
                        default:
                            typeClass = 'text';
                            typeIcon = 'bi-fonts';
                            typeLabel = 'Texto';
                            typeColor = 'rgba(255, 107, 107, 0.5)';
                    }
                    
                    columnsHtml += `
                        <div class="column-detail-item" style="background: rgba(0, 212, 255, 0.05); 
                             border: 1px solid rgba(0, 212, 255, 0.3); 
                             border-radius: 10px; 
                             padding: 15px; 
                             margin-bottom: 10px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <span style="font-weight: bold; color: var(--primary-color); font-size: 1.1rem;">
                                        ${colInfo.name}
                                    </span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 15px;">
                                    <span style="background: ${typeColor}; 
                                                 padding: 4px 12px; 
                                                 border-radius: 20px; 
                                                 font-size: 0.9rem;
                                                 color: white;
                                                 display: flex;
                                                 align-items: center;
                                                 gap: 5px;">
                                        <i class="bi ${typeIcon}"></i> ${typeLabel}
                                    </span>
                                    <span style="background: rgba(0, 0, 0, 0.3); 
                                                 padding: 4px 10px; 
                                                 border-radius: 5px; 
                                                 font-family: monospace; 
                                                 font-size: 0.85rem; 
                                                 color: #00d4ff;">
                                        ${colInfo.dtype}
                                    </span>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                columnsHtml += `
                        </div>
                    </div>
                `;
            } else {
                // Fallback: mostrar las columnas esperadas sin información de tipos
                columnsHtml = `
                    <div class="column-details-container">
                        <h5 style="color: var(--primary-color); margin-bottom: 20px;">
                            <i class="bi bi-table"></i> Columnas esperadas
                        </h5>
                        <div class="columns-list">
                `;
                
                expectedColumns.forEach((colName, idx) => {
                    columnsHtml += `
                        <div class="column-detail-item" style="background: rgba(0, 212, 255, 0.05); 
                             border: 1px solid rgba(0, 212, 255, 0.3); 
                             border-radius: 10px; 
                             padding: 15px; 
                             margin-bottom: 10px;">
                            <span style="font-weight: bold; color: var(--primary-color);">
                                ${idx + 1}. ${colName}
                            </span>
                        </div>
                    `;
                });
                
                columnsHtml += `
                        </div>
                        <div style="margin-top: 15px; color: rgba(240, 249, 255, 0.6); font-size: 0.9rem;">
                            <i class="bi bi-info-circle"></i> Los tipos de datos se detectarán automáticamente al aplicar la función
                        </div>
                    </div>
                `;
            }
            
            // Mostrar en un modal
            const modal = document.createElement('div');
            modal.className = 'modal fade';
            modal.innerHTML = `
                <div class="modal-dialog modal-dialog-centered">
                    <div class="modal-content" style="background: rgba(15, 17, 20, 0.95); border: 1px solid rgba(0, 212, 255, 0.3);">
                        <div class="modal-header" style="border-bottom: 1px solid rgba(0, 212, 255, 0.2);">
                            <h5 class="modal-title" style="color: var(--light-color);">
                                Detalles de columnas - ${column}
                            </h5>
                            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            ${columnsHtml}
                        </div>
                        <div class="modal-footer" style="border-top: 1px solid rgba(0, 212, 255, 0.2);">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cerrar</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            const bsModal = new bootstrap.Modal(modal);
            bsModal.show();
            
            // Limpiar el modal cuando se cierre
            modal.addEventListener('hidden.bs.modal', function () {
                modal.remove();
            });
        })
        .catch(error => {
            loadingModal.hide();
            console.error('Error getting column details:', error);
            showNotification('Error al obtener detalles de las columnas', 'error');
        });
    }
    
    window.editFunction = async function(functionId) {
        console.log('editFunction called with ID:', functionId);
        try {
            // Obtener la función específica directamente para evitar datos cacheados
            const timestamp = new Date().getTime();
            const response = await fetch(`/api/custom-normalization-functions/${functionId}/?t=${timestamp}`, {
                method: 'GET',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken')
                },
                cache: 'no-store'
            });
            console.log('Response status:', response.status);
            if (response.ok) {
                const functionData = await response.json();
                console.log('Function loaded directly:', functionData);
                console.log('Code preview:', functionData.code ? functionData.code.substring(0, 100) + '...' : 'No code');
                
                if (functionData) {
                    // Cerrar el modal de gestión
                    const manageModal = bootstrap.Modal.getInstance(document.getElementById('manageFunctionsModal'));
                    if (manageModal) {
                        manageModal.hide();
                    }
                    
                    // Abrir el modal de edición
                    setTimeout(() => {
                        console.log('Opening custom function modal...');
                        openCustomFunctionModal(functionData);
                    }, 300);
                } else {
                    console.error('Function not found with ID:', functionId);
                    showNotification('Función no encontrada', 'error');
                }
            } else {
                console.error('Failed to load functions, status:', response.status);
                showNotification('Error al cargar las funciones', 'error');
            }
        } catch (error) {
            console.error('Error loading function:', error);
            showNotification('Error al cargar la función', 'error');
        }
    }
    
    window.deleteFunction = async function(functionId, functionName) {
        if (!confirm(`¿Estás seguro de eliminar la función "${functionName}"?`)) {
            return;
        }
        
        try {
            const response = await fetch(`/api/custom-normalization-functions/${functionId}/`, {
                method: 'DELETE',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken')
                }
            });
            
            if (response.ok) {
                showNotification('Función eliminada exitosamente', 'success');
                await loadFunctionsForManagement();
                await loadDatasetInfo(); // Recargar para actualizar las opciones
            } else {
                showNotification('Error al eliminar la función', 'error');
            }
        } catch (error) {
            console.error('Error deleting function:', error);
            showNotification('Error de conexión', 'error');
        }
    }
    
    // Fin del script - todas las funciones cerradas correctamente
</script>
{% endblock %}